{"version":3,"file":"index-BgMd59JL.js","sources":["../../admin/src/utils/getTrad.ts","../../admin/src/contexts/DataManagerContext.ts","../../admin/src/hooks/useDataManager.ts","../../admin/src/contexts/FormModalNavigationContext.ts","../../admin/src/hooks/useFormModalNavigation.ts","../../admin/src/components/ContentTypeBuilderNav/useContentTypeBuilderMenu.ts","../../admin/src/components/ContentTypeBuilderNav/ContentTypeBuilderNav.tsx","../../admin/src/utils/isAllowedContentTypesForRelations.ts","../../admin/src/utils/findAttribute.ts","../../admin/src/utils/getYupInnerErrors.ts","../../admin/src/components/AllowedTypesSelect.tsx","../../admin/src/components/AttributeIcon.tsx","../../admin/src/components/AttributeOptions/OptionBoxWrapper.tsx","../../admin/src/components/AttributeOptions/AttributeOption.tsx","../../admin/src/components/AttributeOptions/AttributeList.tsx","../../admin/src/components/AttributeOptions/CustomFieldOption.tsx","../../admin/src/components/AttributeOptions/EmptyAttributes.tsx","../../admin/src/components/AttributeOptions/CustomFieldsList.tsx","../../admin/src/components/AttributeOptions/AttributeOptions.tsx","../../admin/src/components/BooleanDefaultValueSelect.tsx","../../admin/src/components/CustomRadioGroup/Styles.tsx","../../admin/src/components/CustomRadioGroup/CustomRadioGroup.tsx","../../admin/src/components/BooleanRadioGroup.tsx","../../admin/src/components/CheckboxWithNumberField.tsx","../../admin/src/components/ContentTypeRadioGroup.tsx","../../admin/src/components/DraftAndPublishToggle.tsx","../../admin/src/components/FormModalEndActions.tsx","../../admin/src/components/FormModalHeader.tsx","../../admin/src/components/FormModalSubHeader.tsx","../../admin/src/components/IconPicker/constants.ts","../../admin/src/components/IconPicker/IconPicker.tsx","../../admin/src/components/PluralName.tsx","../../admin/src/utils/parseDateValue.ts","../../admin/src/utils/timeFormat.ts","../../admin/src/components/GenericInputs.tsx","../../admin/src/components/Relation/RelationField/RelationTargetPicker/RelationTargetPicker.tsx","../../admin/src/components/Relation/RelationField/RelationField.tsx","../../admin/src/components/Relation/RelationNaturePicker/Components.tsx","../../admin/src/components/Relation/RelationNaturePicker/RelationNaturePicker.tsx","../../admin/src/components/Relation/Relation.tsx","../../admin/src/components/SelectCategory.tsx","../../admin/src/utils/getMaxDepth.ts","../../admin/src/components/SelectComponent.tsx","../../admin/src/components/SelectComponents.tsx","../../admin/src/components/SelectDateType.tsx","../../admin/src/components/SelectNumber.tsx","../../admin/src/components/SingularName.tsx","../../admin/src/components/TabForm.tsx","../../admin/src/components/TextareaEnum.tsx","../../admin/src/components/FormModal/attributes/nameField.ts","../../admin/src/components/FormModal/attributes/commonBaseForm.ts","../../admin/src/components/FormModal/component/componentForm.ts","../../admin/src/components/FormModal/attributes/attributeOptions.ts","../../admin/src/components/FormModal/attributes/advancedForm.ts","../../admin/src/components/FormModal/component/componentField.ts","../../admin/src/components/FormModal/attributes/baseForm.ts","../../admin/src/components/FormModal/attributes/form.ts","../../admin/src/utils/toRegressedEnumValue.ts","../../admin/src/components/FormModal/attributes/validation/common.ts","../../admin/src/components/FormModal/attributes/types.ts","../../admin/src/components/FormModal/category/regex.ts","../../admin/src/components/FormModal/category/createCategorySchema.ts","../../admin/src/components/FormModal/category/form.ts","../../admin/src/components/FormModal/component/createComponentSchema.ts","../../admin/src/components/FormModal/contentType/contentTypeForm.ts","../../admin/src/components/FormModal/contentType/createContentTypeSchema.ts","../../admin/src/components/FormModal/dynamiczoneForm.ts","../../admin/src/components/FormModal/forms/utils/addItemsToFormSection.ts","../../admin/src/components/FormModal/forms/utils/createCollectionName.ts","../../admin/src/components/FormModal/forms/utils/getUsedAttributeNames.ts","../../admin/src/components/FormModal/forms/forms.ts","../../admin/src/components/FormModal/selectors.ts","../../admin/src/components/FormModal/utils/canEditContentType.ts","../../admin/src/components/FormModal/utils/getAttributesToDisplay.ts","../../admin/src/components/FormModal/utils/getFormInputNames.ts","../../admin/src/components/FormModal/FormModal.tsx","../../admin/src/components/DataManagerProvider/selectors.ts","../../admin/src/components/DataManagerProvider/utils/cleanData.ts","../../admin/src/components/DataManagerProvider/utils/createDataObject.ts","../../admin/src/components/DataManagerProvider/utils/createModifiedDataSchema.ts","../../admin/src/components/DataManagerProvider/utils/formatSchemas.ts","../../admin/src/components/DataManagerProvider/utils/retrieveComponentsThatHaveComponents.ts","../../admin/src/components/DataManagerProvider/utils/retrieveNestedComponents.ts","../../admin/src/components/DataManagerProvider/utils/retrieveSpecificInfoFromComponents.ts","../../admin/src/components/DataManagerProvider/utils/serverRestartWatcher.ts","../../admin/src/components/DataManagerProvider/utils/validateSchema.ts","../../admin/src/components/DataManagerProvider/DataManagerProvider.tsx","../../admin/src/components/FormModalNavigationProvider/constants.ts","../../admin/src/components/FormModalNavigationProvider/FormModalNavigationProvider.tsx","../../admin/src/pages/RecursivePath/RecursivePath.tsx","../../admin/src/pages/App/index.tsx"],"sourcesContent":["import { pluginId } from '../pluginId';\n\nexport const getTrad = (id: string) => `${pluginId}.${id}`;\n","/* eslint-disable check-file/filename-naming-convention */\nimport { createContext } from 'react';\n\nimport type { SchemaType, Component } from '../types';\nimport type { Internal } from '@strapi/types';\n\n// TODO V5 Convert this any types to real types\nexport interface CustomFieldAttributeParams {\n  attributeToSet: Record<string, any>;\n  forTarget: SchemaType;\n  targetUid: Internal.UID.Schema;\n  initialAttribute: Record<string, any>;\n}\nexport interface DataManagerContextValue {\n  addAttribute: (\n    attributeToSet: Record<string, any>,\n    forTarget: SchemaType,\n    targetUid: Internal.UID.Schema,\n    isEditing?: boolean,\n    initialAttribute?: Record<string, any>,\n    shouldAddComponentToData?: boolean\n  ) => void;\n  addCustomFieldAttribute: (params: CustomFieldAttributeParams) => void;\n  editCustomFieldAttribute: (params: CustomFieldAttributeParams) => void;\n  addCreatedComponentToDynamicZone: (dynamicZoneTarget: string, componentsToAdd: string[]) => void;\n  createSchema: (\n    data: Record<string, any>,\n    schemaType: SchemaType,\n    uid: Internal.UID.Schema,\n    componentCategory?: string,\n    shouldAddComponentToData?: boolean\n  ) => void;\n  changeDynamicZoneComponents: (dynamicZoneTarget: string, newComponents: string[]) => void;\n  removeAttribute: (\n    mainDataKey: string,\n    attributeToRemoveName: string,\n    componentUid?: string\n  ) => void;\n  deleteCategory: (categoryUid: string) => void;\n  deleteData: () => void;\n  editCategory: (categoryUid: string, body: any) => void;\n  removeComponentFromDynamicZone: (dzName: string, componentToRemoveIndex: number) => void;\n  setModifiedData: () => void;\n  sortedContentTypesList: any[]; // Define the actual type\n  submitData: (additionalContentTypeData?: Record<string, any>) => Promise<void>;\n  updateSchema: (\n    data: Record<string, any>,\n    schemaType: SchemaType,\n    componentUID: Internal.UID.Component\n  ) => void;\n  components: Record<Internal.UID.Component, Component>;\n  componentsGroupedByCategory: Record<string, Component[]>;\n  componentsThatHaveOtherComponentInTheirAttributes: any[]; // Define the actual type\n  contentTypes: Record<string, any>;\n  initialData: Record<string, any>;\n  isInContentTypeView: boolean;\n  isInDevelopmentMode?: boolean;\n  modifiedData: Record<string, any>;\n  nestedComponents: any[]; // Define the actual type\n  reservedNames: {\n    models: string[];\n    attributes: string[];\n  };\n  allComponentsCategories: any[];\n}\n\n// @ts-expect-error need to pass initial value to params\nexport const DataManagerContext = createContext<DataManagerContextValue>();\n","import { useContext } from 'react';\n\nimport { DataManagerContext } from '../contexts/DataManagerContext';\n\nexport const useDataManager = () => useContext(DataManagerContext);\n","/* eslint-disable check-file/filename-naming-convention */\nimport * as React from 'react';\n\nimport { INITIAL_STATE_DATA } from '../components/FormModalNavigationProvider/constants';\n\nimport type {\n  ModalEventProps,\n  State,\n} from '../components/FormModalNavigationProvider/FormModalNavigationProvider';\nimport type { SchemaType } from '../types';\nimport type { Internal } from '@strapi/types';\n\nexport interface FormModalNavigationContextValue {\n  onCloseModal: () => void;\n  onOpenModalAddField: (options: {\n    forTarget: SchemaType;\n    targetUid?: Internal.UID.Schema;\n  }) => void;\n  onClickSelectField: (option: ModalEventProps) => void;\n  onClickSelectCustomField: (option: ModalEventProps) => void;\n  onNavigateToChooseAttributeModal: (options: ModalEventProps) => void;\n  onNavigateToAddCompoToDZModal: (options: ModalEventProps) => void;\n  onOpenModalAddComponentsToDZ: (options: ModalEventProps) => void;\n  onNavigateToCreateComponentStep2: () => void;\n  onOpenModalCreateSchema: (options: State) => void;\n  onOpenModalEditCategory: (categoryName: string) => void;\n  onOpenModalEditField: (options: ModalEventProps) => void;\n  onOpenModalEditCustomField: (options: ModalEventProps) => void;\n  onOpenModalEditSchema: (options: ModalEventProps) => void;\n  setFormModalNavigationState: (value: React.SetStateAction<typeof INITIAL_STATE_DATA>) => void;\n  actionType: string;\n  attributeName: string;\n  attributeType: string;\n  customFieldUid: string;\n  categoryName: string;\n  dynamicZoneTarget: string;\n  forTarget: SchemaType;\n  modalType: string;\n  isOpen: boolean;\n  showBackLink: boolean;\n  kind: string;\n  step: string;\n  targetUid: Internal.UID.Schema;\n  activeTab: string;\n  setActiveTab: (value: React.SetStateAction<string>) => void;\n}\n\n// @ts-expect-error need to pass initial value to params\nexport const FormModalNavigationContext = React.createContext<FormModalNavigationContextValue>();\n","import { useContext } from 'react';\n\nimport { FormModalNavigationContext } from '../contexts/FormModalNavigationContext';\n\nexport const useFormModalNavigation = () => useContext(FormModalNavigationContext);\n","import { useState, MouseEvent } from 'react';\n\nimport { useTracking, useNotification } from '@strapi/admin/strapi-admin';\nimport { useCollator, useFilter } from '@strapi/design-system';\nimport isEqual from 'lodash/isEqual';\nimport { useIntl } from 'react-intl';\n\nimport { useDataManager } from '../../hooks/useDataManager';\nimport { useFormModalNavigation } from '../../hooks/useFormModalNavigation';\nimport { pluginId } from '../../pluginId';\nimport { getTrad } from '../../utils/getTrad';\n\nimport type { Internal } from '@strapi/types';\n\nexport const useContentTypeBuilderMenu = () => {\n  const {\n    components,\n    componentsGroupedByCategory,\n    contentTypes,\n    isInDevelopmentMode,\n    sortedContentTypesList,\n    modifiedData,\n    initialData,\n  } = useDataManager();\n  const { toggleNotification } = useNotification();\n  const { formatMessage } = useIntl();\n  const { trackUsage } = useTracking();\n  const [search, setSearch] = useState('');\n  const { onOpenModalCreateSchema, onOpenModalEditCategory } = useFormModalNavigation();\n  const { locale } = useIntl();\n\n  const { startsWith } = useFilter(locale, {\n    sensitivity: 'base',\n  });\n\n  const formatter = useCollator(locale, {\n    sensitivity: 'base',\n  });\n\n  const canOpenModalCreateCTorComponent =\n    !Object.keys(contentTypes).some((ct) => contentTypes[ct].isTemporary === true) &&\n    !Object.keys(components).some(\n      (component) => components[component as Internal.UID.Component].isTemporary === true\n    ) &&\n    isEqual(modifiedData, initialData);\n\n  const handleClickOpenModalCreateCollectionType = () => {\n    if (canOpenModalCreateCTorComponent) {\n      trackUsage(`willCreateContentType`);\n\n      const nextState = {\n        modalType: 'contentType',\n        kind: 'collectionType',\n        actionType: 'create',\n        forTarget: 'contentType',\n      };\n\n      onOpenModalCreateSchema(nextState);\n    } else {\n      toggleNotificationCannotCreateSchema();\n    }\n  };\n\n  const handleClickOpenModalCreateSingleType = () => {\n    if (canOpenModalCreateCTorComponent) {\n      trackUsage(`willCreateSingleType`);\n\n      const nextState = {\n        modalType: 'contentType',\n        kind: 'singleType',\n        actionType: 'create',\n        forTarget: 'contentType',\n      };\n\n      onOpenModalCreateSchema(nextState);\n    } else {\n      toggleNotificationCannotCreateSchema();\n    }\n  };\n\n  const handleClickOpenModalCreateComponent = () => {\n    if (canOpenModalCreateCTorComponent) {\n      trackUsage('willCreateComponent');\n\n      const nextState = {\n        modalType: 'component',\n        kind: null,\n        actionType: 'create',\n        forTarget: 'component',\n      };\n\n      onOpenModalCreateSchema(nextState);\n    } else {\n      toggleNotificationCannotCreateSchema();\n    }\n  };\n\n  const toggleNotificationCannotCreateSchema = () => {\n    toggleNotification({\n      type: 'info',\n      message: formatMessage({\n        id: getTrad('notification.info.creating.notSaved'),\n        defaultMessage: 'Please save your work before creating a new collection type or component',\n      }),\n    });\n  };\n\n  const componentsData = Object.entries(componentsGroupedByCategory)\n    .map(([category, components]) => ({\n      name: category,\n      title: category,\n      isEditable: isInDevelopmentMode,\n      onClickEdit(e: MouseEvent, data: any) {\n        e.stopPropagation();\n\n        if (canOpenModalCreateCTorComponent) {\n          onOpenModalEditCategory(data.name);\n        } else {\n          toggleNotificationCannotCreateSchema();\n        }\n      },\n      links: components\n        .map((component) => ({\n          name: component.uid,\n          to: `/plugins/${pluginId}/component-categories/${category}/${component.uid}`,\n          title: component.schema.displayName,\n        }))\n        .sort((a, b) => formatter.compare(a.title, b.title)),\n    }))\n    .sort((a, b) => formatter.compare(a.title, b.title));\n\n  const displayedContentTypes = sortedContentTypesList.filter((obj) => obj.visible);\n\n  const data = [\n    {\n      name: 'models',\n      title: {\n        id: `${getTrad('menu.section.models.name')}`,\n        defaultMessage: 'Collection Types',\n      },\n      customLink: isInDevelopmentMode && {\n        id: `${getTrad('button.model.create')}`,\n        defaultMessage: 'Create new collection type',\n        onClick: handleClickOpenModalCreateCollectionType,\n      },\n      links: displayedContentTypes.filter((contentType) => contentType.kind === 'collectionType'),\n    },\n    {\n      name: 'singleTypes',\n      title: {\n        id: `${getTrad('menu.section.single-types.name')}`,\n        defaultMessage: 'Single Types',\n      },\n      customLink: isInDevelopmentMode && {\n        id: `${getTrad('button.single-types.create')}`,\n        defaultMessage: 'Create new single type',\n        onClick: handleClickOpenModalCreateSingleType,\n      },\n      links: displayedContentTypes.filter((singleType) => singleType.kind === 'singleType'),\n    },\n    {\n      name: 'components',\n      title: {\n        id: `${getTrad('menu.section.components.name')}`,\n        defaultMessage: 'Components',\n      },\n      customLink: isInDevelopmentMode && {\n        id: `${getTrad('button.component.create')}`,\n        defaultMessage: 'Create a new component',\n        onClick: handleClickOpenModalCreateComponent,\n      },\n      links: componentsData,\n    },\n  ].map((section) => {\n    const hasChild = section.links.some((l) => Array.isArray(l.links));\n\n    if (hasChild) {\n      let filteredLinksCount = 0;\n\n      return {\n        ...section,\n        links: section.links\n          .map((link) => {\n            const filteredLinks = link.links.filter((link: any) => startsWith(link.title, search));\n\n            if (filteredLinks.length === 0) {\n              return null;\n            }\n\n            filteredLinksCount += filteredLinks.length;\n\n            return {\n              ...link,\n              links: filteredLinks.sort((a: any, b: any) => formatter.compare(a.title, b.title)),\n            };\n          })\n          .filter(Boolean),\n        linksCount: filteredLinksCount,\n      };\n    }\n\n    const filteredLinks = section.links\n      .filter((link) => startsWith(link.title, search))\n      .sort((a, b) => formatter.compare(a.title, b.title));\n\n    return {\n      ...section,\n      links: filteredLinks,\n      linksCount: filteredLinks.length,\n    };\n  });\n\n  return {\n    menu: data,\n    searchValue: search,\n    onSearchChange: setSearch,\n  };\n};\n","import { Fragment } from 'react';\n\nimport {\n  Box,\n  TextButton,\n  SubNav,\n  SubNavHeader,\n  SubNavLink,\n  SubNavLinkSection,\n  SubNavSection,\n  SubNavSections,\n} from '@strapi/design-system';\nimport { Plus } from '@strapi/icons';\nimport upperFirst from 'lodash/upperFirst';\nimport { useIntl } from 'react-intl';\nimport { NavLink } from 'react-router-dom';\nimport { styled } from 'styled-components';\n\nimport { getTrad } from '../../utils/getTrad';\n\nimport { useContentTypeBuilderMenu } from './useContentTypeBuilderMenu';\n\nconst SubNavLinkCustom = styled(SubNavLink)`\n  div {\n    width: inherit;\n    span:nth-child(2) {\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      width: inherit;\n    }\n  }\n`;\n\nexport const ContentTypeBuilderNav = () => {\n  const { menu, searchValue, onSearchChange } = useContentTypeBuilderMenu();\n  const { formatMessage } = useIntl();\n\n  const pluginName = formatMessage({\n    id: getTrad('plugin.name'),\n    defaultMessage: 'Content-Type Builder',\n  });\n\n  return (\n    <SubNav aria-label={pluginName}>\n      <SubNavHeader\n        searchable\n        value={searchValue}\n        onClear={() => onSearchChange('')}\n        onChange={(e) => onSearchChange(e.target.value)}\n        label={pluginName}\n        searchLabel={formatMessage({\n          id: 'global.search',\n          defaultMessage: 'Search',\n        })}\n      />\n      <SubNavSections>\n        {menu.map((section) => (\n          <Fragment key={section.name}>\n            <SubNavSection\n              label={formatMessage({\n                id: section.title.id,\n                defaultMessage: section.title.defaultMessage,\n              })}\n              collapsable\n              badgeLabel={section.linksCount.toString()}\n            >\n              {section.links.map((link) => {\n                if (link.links) {\n                  return (\n                    <SubNavLinkSection key={link.name} label={upperFirst(link.title)}>\n                      {link.links.map((subLink: any) => (\n                        <SubNavLink\n                          tag={NavLink}\n                          to={subLink.to}\n                          active={subLink.active}\n                          key={subLink.name}\n                          isSubSectionChild\n                        >\n                          {upperFirst(\n                            formatMessage({ id: subLink.name, defaultMessage: subLink.title })\n                          )}\n                        </SubNavLink>\n                      ))}\n                    </SubNavLinkSection>\n                  );\n                }\n\n                return (\n                  <SubNavLinkCustom\n                    tag={NavLink}\n                    to={link.to}\n                    active={link.active}\n                    key={link.name}\n                    width=\"100%\"\n                  >\n                    {upperFirst(formatMessage({ id: link.name, defaultMessage: link.title }))}\n                  </SubNavLinkCustom>\n                );\n              })}\n            </SubNavSection>\n            {section.customLink && (\n              <Box paddingLeft={7}>\n                <TextButton\n                  onClick={section.customLink.onClick}\n                  startIcon={<Plus width=\"0.8rem\" height=\"0.8rem\" />}\n                  marginTop={2}\n                  cursor=\"pointer\"\n                >\n                  {formatMessage({\n                    id: section.customLink.id,\n                    defaultMessage: section.customLink.defaultMessage,\n                  })}\n                </TextButton>\n              </Box>\n            )}\n          </Fragment>\n        ))}\n      </SubNavSections>\n    </SubNav>\n  );\n};\n","import type { ContentType } from '../types';\n\nexport const isAllowedContentTypesForRelations = (contentType: ContentType) => {\n  return (\n    contentType.kind === 'collectionType' &&\n    (contentType.restrictRelationsTo === null ||\n      (Array.isArray(contentType.restrictRelationsTo) &&\n        contentType.restrictRelationsTo.length > 0))\n  );\n};\n","import { AttributeType } from '../types';\n\nexport const findAttribute = (attributes: AttributeType[], attributeToFind: string) => {\n  return attributes.find(({ name }) => name === attributeToFind);\n};\n","import type { MessageDescriptor, PrimitiveType } from 'react-intl';\nimport type { ValidationError } from 'yup';\n\ninterface TranslationMessage extends MessageDescriptor {\n  values?: Record<string, PrimitiveType>;\n}\n\nconst extractValuesFromYupError = (\n  errorType?: string | undefined,\n  errorParams?: Record<string, any> | undefined\n) => {\n  if (!errorType || !errorParams) {\n    return {};\n  }\n\n  return {\n    [errorType]: errorParams[errorType],\n  };\n};\n\nconst getYupInnerErrors = (error: ValidationError) =>\n  (error?.inner || []).reduce<Record<string, TranslationMessage>>((acc, currentError) => {\n    if (currentError.path) {\n      acc[currentError.path.split('[').join('.').split(']').join('')] = {\n        id: currentError.message,\n        defaultMessage: currentError.message,\n        values: extractValuesFromYupError(currentError?.type, currentError?.params),\n      };\n    }\n\n    return acc;\n  }, {});\n\nexport { getYupInnerErrors };\n","import { Field, MultiSelectNested } from '@strapi/design-system';\nimport upperFirst from 'lodash/upperFirst';\nimport { useIntl } from 'react-intl';\n\nimport { IntlLabel } from '../types';\n\ninterface AllowedTypesSelectProps {\n  intlLabel: IntlLabel;\n  name: string;\n  onChange: (value: any) => void;\n  value?: any;\n}\n\nconst options = [\n  {\n    label: 'All',\n    children: [\n      { label: 'images (JPEG, PNG, GIF, SVG, TIFF, ICO, DVU)', value: 'images' },\n      { label: 'videos (MPEG, MP4, Quicktime, WMV, AVI, FLV)', value: 'videos' },\n      { label: 'audios (MP3, WAV, OGG)', value: 'audios' },\n      { label: 'files (CSV, ZIP, PDF, Excel, JSON, ...)', value: 'files' },\n    ],\n  },\n];\n\nexport const AllowedTypesSelect = ({\n  intlLabel,\n  name,\n  onChange,\n  value = null,\n}: AllowedTypesSelectProps) => {\n  const { formatMessage } = useIntl();\n\n  /* eslint-disable indent */\n  const displayedValue =\n    value === null || value?.length === 0\n      ? formatMessage({ id: 'global.none', defaultMessage: 'None' })\n      : [...value]\n          .sort()\n          .map((v) => upperFirst(v))\n          .join(', ');\n\n  /* eslint-enable indent */\n\n  const label = intlLabel.id\n    ? formatMessage({ id: intlLabel.id, defaultMessage: intlLabel.defaultMessage })\n    : name;\n\n  return (\n    <Field.Root name={name}>\n      <Field.Label>{label}</Field.Label>\n      <MultiSelectNested\n        customizeContent={() => displayedValue}\n        onChange={(values: any[]) => {\n          if (values.length > 0) {\n            onChange({ target: { name, value: values, type: 'allowed-types-select' } });\n          } else {\n            onChange({ target: { name, value: null, type: 'allowed-types-select' } });\n          }\n        }}\n        options={options}\n        value={value || []}\n      />\n    </Field.Root>\n  );\n};\n","import { ComponentType, SVGProps } from 'react';\n\nimport { useStrapiApp } from '@strapi/admin/strapi-admin';\nimport { Box } from '@strapi/design-system';\nimport {\n  BooleanField,\n  CollectionType,\n  ComponentField,\n  DateField,\n  DynamicZoneField,\n  EmailField,\n  EnumerationField,\n  JsonField,\n  MediaField,\n  NumberField,\n  PasswordField,\n  RelationField,\n  MarkdownField,\n  SingleType,\n  TextField,\n  UidField,\n  BlocksField,\n} from '@strapi/icons/symbols';\nimport { styled } from 'styled-components';\n\nconst iconByTypes: Record<string, ComponentType<SVGProps<SVGSVGElement>>> = {\n  biginteger: NumberField,\n  blocks: BlocksField,\n  boolean: BooleanField,\n  collectionType: CollectionType,\n  component: ComponentField,\n  contentType: CollectionType,\n  date: DateField,\n  datetime: DateField,\n  decimal: NumberField,\n  dynamiczone: DynamicZoneField,\n  email: EmailField,\n  enum: EnumerationField,\n  enumeration: EnumerationField,\n  file: MediaField,\n  files: MediaField,\n  float: NumberField,\n  integer: NumberField,\n  json: JsonField,\n  JSON: JsonField,\n  media: MediaField,\n  number: NumberField,\n  password: PasswordField,\n  relation: RelationField,\n  richtext: MarkdownField,\n  singleType: SingleType,\n  string: TextField,\n  text: TextField,\n  time: DateField,\n  timestamp: DateField,\n  uid: UidField,\n};\n\nconst IconBox = styled(Box)`\n  svg {\n    height: 100%;\n    width: 100%;\n  }\n`;\n\nexport type IconByType = keyof typeof iconByTypes;\n\ntype AttributeIconProps = {\n  type: IconByType;\n  customField?: string | null;\n};\n\nexport const AttributeIcon = ({ type, customField = null, ...rest }: AttributeIconProps) => {\n  const getCustomField = useStrapiApp('AttributeIcon', (state) => state.customFields.get);\n\n  let Compo: any = iconByTypes[type];\n\n  if (customField) {\n    const customFieldObject = getCustomField(customField);\n    const icon = customFieldObject?.icon;\n    if (icon) {\n      Compo = icon;\n    }\n  }\n\n  if (!iconByTypes[type]) {\n    return null;\n  }\n\n  return (\n    <IconBox width=\"3.2rem\" shrink={0} {...rest} aria-hidden>\n      <Box tag={Compo} />\n    </IconBox>\n  );\n};\n","import { Box } from '@strapi/design-system';\nimport { styled } from 'styled-components';\n\nexport const OptionBoxWrapper = styled(Box)`\n  width: 100%;\n  height: 100%;\n  border: 1px solid ${({ theme }) => theme.colors.neutral200};\n  text-align: left;\n  &:hover {\n    cursor: pointer;\n    background: ${({ theme }) => theme.colors.primary100};\n    border: 1px solid ${({ theme }) => theme.colors.primary200};\n  }\n`;\n","/**\n *\n * AttributeOption\n *\n */\n\nimport { Box, Flex, Typography } from '@strapi/design-system';\nimport { Sparkle } from '@strapi/icons';\nimport { useIntl } from 'react-intl';\n\nimport { useFormModalNavigation } from '../../hooks/useFormModalNavigation';\nimport { getTrad } from '../../utils/getTrad';\nimport { AttributeIcon, IconByType } from '../AttributeIcon';\n\nimport { OptionBoxWrapper } from './OptionBoxWrapper';\n\nconst newAttributes: string[] = [];\n\nconst NewBadge = () => (\n  <Flex grow={1} justifyContent=\"flex-end\">\n    <Flex gap={1} hasRadius background=\"alternative100\" padding={`0.2rem 0.4rem`}>\n      <Sparkle width={`1rem`} height={`1rem`} fill=\"alternative600\" />\n      <Typography textColor=\"alternative600\" variant=\"sigma\">\n        New\n      </Typography>\n    </Flex>\n  </Flex>\n);\n\ntype AttributeOptionProps = {\n  type: IconByType;\n};\n\nexport const AttributeOption = ({ type = 'text' }: AttributeOptionProps) => {\n  const { formatMessage } = useIntl();\n\n  const { onClickSelectField } = useFormModalNavigation();\n\n  const handleClick = () => {\n    const step = type === 'component' ? '1' : null;\n\n    onClickSelectField({\n      attributeType: type,\n      step,\n    });\n  };\n\n  return (\n    <OptionBoxWrapper padding={4} tag=\"button\" hasRadius type=\"button\" onClick={handleClick}>\n      <Flex>\n        <AttributeIcon type={type} />\n        <Box paddingLeft={4} width=\"100%\">\n          <Flex justifyContent=\"space-between\">\n            <Typography fontWeight=\"bold\" textColor=\"neutral800\">\n              {formatMessage({ id: getTrad(`attribute.${type}`), defaultMessage: type })}\n            </Typography>\n            {newAttributes.includes(type) && <NewBadge />}\n          </Flex>\n          <Flex>\n            <Typography variant=\"pi\" textColor=\"neutral600\">\n              {formatMessage({\n                id: getTrad(`attribute.${type}.description`),\n                defaultMessage: 'A type for modeling data',\n              })}\n            </Typography>\n          </Flex>\n        </Box>\n      </Flex>\n    </OptionBoxWrapper>\n  );\n};\n","import { Flex, Grid, KeyboardNavigable } from '@strapi/design-system';\n\nimport { IconByType } from '../AttributeIcon';\n\nimport { AttributeOption } from './AttributeOption';\n\ntype AttributeListProps = {\n  attributes: IconByType[][];\n};\n\nexport const AttributeList = ({ attributes }: AttributeListProps) => (\n  <KeyboardNavigable tagName=\"button\">\n    <Flex direction=\"column\" alignItems=\"stretch\" gap={8}>\n      {attributes.map((attributeRow, index) => {\n        return (\n          // eslint-disable-next-line react/no-array-index-key\n          <Grid.Root key={index} gap={3}>\n            {attributeRow.map((attribute) => (\n              <Grid.Item key={attribute} col={6} direction=\"column\" alignItems=\"stretch\">\n                <AttributeOption type={attribute} />\n              </Grid.Item>\n            ))}\n          </Grid.Root>\n        );\n      })}\n    </Flex>\n  </KeyboardNavigable>\n);\n","import * as React from 'react';\n\nimport { StrapiAppContextValue } from '@strapi/admin/strapi-admin';\nimport { Box, Flex, Typography } from '@strapi/design-system';\nimport { useIntl } from 'react-intl';\n\nimport { useFormModalNavigation } from '../../hooks/useFormModalNavigation';\nimport { AttributeIcon, IconByType } from '../AttributeIcon';\n\nimport { OptionBoxWrapper } from './OptionBoxWrapper';\n\nexport type CustomFieldOption = {\n  name: string;\n  type: IconByType;\n  icon: React.ComponentType;\n  intlLabel: {\n    id: string;\n    defaultMessage: string;\n  };\n  intlDescription: {\n    id: string;\n    defaultMessage: string;\n  };\n};\n\ntype CustomFieldOptionProps = {\n  customFieldUid: string;\n  customField: NonNullable<ReturnType<StrapiAppContextValue['customFields']['get']>>;\n};\n\nexport const CustomFieldOption = ({ customFieldUid, customField }: CustomFieldOptionProps) => {\n  const { type, intlLabel, intlDescription } = customField;\n  const { formatMessage } = useIntl();\n\n  const { onClickSelectCustomField } = useFormModalNavigation();\n\n  const handleClick = () => {\n    onClickSelectCustomField({\n      attributeType: type,\n      customFieldUid,\n    });\n  };\n\n  return (\n    <OptionBoxWrapper padding={4} tag=\"button\" hasRadius type=\"button\" onClick={handleClick}>\n      <Flex>\n        <AttributeIcon type={type} customField={customFieldUid} />\n        <Box paddingLeft={4}>\n          <Flex>\n            <Typography fontWeight=\"bold\" textColor=\"neutral800\">\n              {formatMessage(intlLabel)}\n            </Typography>\n          </Flex>\n          <Flex>\n            <Typography variant=\"pi\" textColor=\"neutral600\">\n              {formatMessage(intlDescription)}\n            </Typography>\n          </Flex>\n        </Box>\n      </Flex>\n    </OptionBoxWrapper>\n  );\n};\n","import { Box, Flex, Typography, LinkButton } from '@strapi/design-system';\nimport { Plus } from '@strapi/icons';\nimport { EmptyDocuments } from '@strapi/icons/symbols';\nimport * as qs from 'qs';\nimport { useIntl } from 'react-intl';\nimport { Link } from 'react-router-dom';\nimport { styled } from 'styled-components';\n\nimport { getTrad } from '../../utils';\n\nconst EmptyCard = styled(Box)`\n  background: ${({ theme }) =>\n    `linear-gradient(180deg, rgba(234, 234, 239, 0) 0%, ${theme.colors.neutral150} 100%)`};\n  opacity: 0.33;\n`;\n\nexport const EmptyCardGrid = () => {\n  return (\n    <Flex wrap=\"wrap\" gap={4}>\n      {[...Array(4)].map((_, idx) => {\n        return (\n          <EmptyCard\n            // eslint-disable-next-line react/no-array-index-key\n            key={`empty-card-${idx}`}\n            height=\"138px\"\n            width=\"375px\"\n            hasRadius\n          />\n        );\n      })}\n    </Flex>\n  );\n};\n\nexport const EmptyAttributes = () => {\n  const { formatMessage } = useIntl();\n\n  return (\n    <Box position=\"relative\">\n      <EmptyCardGrid />\n      <Box position=\"absolute\" top={6} width=\"100%\">\n        <Flex alignItems=\"center\" justifyContent=\"center\" direction=\"column\">\n          <EmptyDocuments width=\"160px\" height=\"88px\" />\n          <Box paddingTop={6} paddingBottom={4}>\n            <Box textAlign=\"center\">\n              <Typography variant=\"delta\" tag=\"p\" textColor=\"neutral600\">\n                {formatMessage({\n                  id: getTrad('modalForm.empty.heading'),\n                  defaultMessage: 'Nothing in here yet.',\n                })}\n              </Typography>\n              <Box paddingTop={4}>\n                <Typography variant=\"delta\" tag=\"p\" textColor=\"neutral600\">\n                  {formatMessage({\n                    id: getTrad('modalForm.empty.sub-heading'),\n                    defaultMessage:\n                      'Find what you are looking for through a wide range of extensions.',\n                  })}\n                </Typography>\n              </Box>\n            </Box>\n          </Box>\n          <LinkButton\n            tag={Link}\n            to={`/marketplace?${qs.stringify({ categories: ['Custom fields'] })}`}\n            variant=\"secondary\"\n            startIcon={<Plus />}\n          >\n            {formatMessage({\n              id: getTrad('modalForm.empty.button'),\n              defaultMessage: 'Add custom fields',\n            })}\n          </LinkButton>\n        </Flex>\n      </Box>\n    </Box>\n  );\n};\n","import { useStrapiApp } from '@strapi/admin/strapi-admin';\nimport { Flex, Grid, KeyboardNavigable, Link } from '@strapi/design-system';\nimport { useIntl } from 'react-intl';\n\nimport { getTrad } from '../../utils';\n\nimport { CustomFieldOption } from './CustomFieldOption';\nimport { EmptyAttributes } from './EmptyAttributes';\n\nexport const CustomFieldsList = () => {\n  const { formatMessage } = useIntl();\n  const getAllCustomFields = useStrapiApp('CustomFieldsList', (state) => state.customFields.getAll);\n  // TODO change this once useCustomFields is typed (helper-plugin types are solved)\n  const registeredCustomFields = Object.entries(getAllCustomFields());\n\n  if (!registeredCustomFields.length) {\n    return <EmptyAttributes />;\n  }\n\n  // Sort the array alphabetically by customField name\n  const sortedCustomFields = registeredCustomFields.sort((a, b) =>\n    a[1].name > b[1].name ? 1 : -1\n  );\n\n  return (\n    <KeyboardNavigable tagName=\"button\">\n      <Flex direction=\"column\" alignItems=\"stretch\" gap={3}>\n        <Grid.Root gap={3}>\n          {sortedCustomFields.map(([uid, customField]) => (\n            <Grid.Item key={uid} col={6} direction=\"column\" alignItems=\"stretch\">\n              <CustomFieldOption key={uid} customFieldUid={uid} customField={customField} />\n            </Grid.Item>\n          ))}\n        </Grid.Root>\n        <Link\n          href=\"https://docs.strapi.io/developer-docs/latest/development/custom-fields.html\"\n          isExternal\n        >\n          {formatMessage({\n            id: getTrad('modalForm.tabs.custom.howToLink'),\n            defaultMessage: 'How to add custom fields',\n          })}\n        </Link>\n      </Flex>\n    </KeyboardNavigable>\n  );\n};\n","/**\n *\n * AttributeOptions\n *\n */\n\nimport { Divider, Flex, Modal, Tabs, Typography } from '@strapi/design-system';\nimport { useIntl } from 'react-intl';\n\nimport { getTrad } from '../../utils';\nimport { IconByType } from '../AttributeIcon';\n\nimport { AttributeList } from './AttributeList';\nimport { CustomFieldsList } from './CustomFieldsList';\n\ntype AttributeOptionsProps = {\n  attributes: IconByType[][];\n  forTarget: string;\n  kind: string;\n};\n\nexport const AttributeOptions = ({ attributes, forTarget, kind }: AttributeOptionsProps) => {\n  const { formatMessage } = useIntl();\n\n  const defaultTabId = getTrad('modalForm.tabs.default');\n  const customTabId = getTrad('modalForm.tabs.custom');\n\n  const titleIdSuffix = forTarget.includes('component') ? 'component' : kind;\n  const titleId = getTrad(`modalForm.sub-header.chooseAttribute.${titleIdSuffix}`);\n\n  return (\n    <Modal.Body>\n      <Tabs.Root variant=\"simple\" defaultValue=\"default\">\n        <Flex justifyContent=\"space-between\">\n          <Typography variant=\"beta\" tag=\"h2\">\n            {formatMessage({ id: titleId, defaultMessage: 'Select a field' })}\n          </Typography>\n          <Tabs.List>\n            <Tabs.Trigger value=\"default\">\n              {formatMessage({ id: defaultTabId, defaultMessage: 'Default' })}\n            </Tabs.Trigger>\n            <Tabs.Trigger value=\"custom\">\n              {formatMessage({ id: customTabId, defaultMessage: 'Custom' })}\n            </Tabs.Trigger>\n          </Tabs.List>\n        </Flex>\n        <Divider marginBottom={6} />\n        <Tabs.Content value=\"default\">\n          <AttributeList attributes={attributes} />\n        </Tabs.Content>\n        <Tabs.Content value=\"custom\">\n          <CustomFieldsList />\n        </Tabs.Content>\n      </Tabs.Root>\n    </Modal.Body>\n  );\n};\n","import { Field, SingleSelect, SingleSelectOption } from '@strapi/design-system';\nimport { useIntl } from 'react-intl';\n\nimport { IntlLabel } from '../types';\n\ninterface Metadata {\n  intlLabel: IntlLabel;\n  disabled?: boolean;\n  hidden?: boolean;\n}\n\ninterface Option {\n  metadatas: Metadata;\n  key: string | number;\n  value: string | number;\n}\n\ninterface BooleanDefaultValueSelectProps {\n  intlLabel: IntlLabel;\n  name: string;\n  onChange: (value: any) => void;\n  options: Option[];\n  value?: any;\n}\n\nexport const BooleanDefaultValueSelect = ({\n  intlLabel,\n  name,\n  options,\n  onChange,\n  value = null,\n}: BooleanDefaultValueSelectProps) => {\n  const { formatMessage } = useIntl();\n  const label = intlLabel.id\n    ? formatMessage(\n        { id: intlLabel.id, defaultMessage: intlLabel.defaultMessage },\n        { ...intlLabel.values }\n      )\n    : name;\n\n  const handleChange = (value: any) => {\n    let nextValue: boolean | string = '';\n\n    if (value === 'true') {\n      nextValue = true;\n    }\n\n    if (value === 'false') {\n      nextValue = false;\n    }\n\n    onChange({ target: { name, value: nextValue, type: 'select-default-boolean' } });\n  };\n\n  return (\n    <Field.Root name={name}>\n      <Field.Label>{label}</Field.Label>\n      <SingleSelect onChange={handleChange} value={(value === null ? '' : value).toString()}>\n        {options.map(({ metadatas: { intlLabel, disabled, hidden }, key, value }) => {\n          return (\n            <SingleSelectOption key={key} value={value} disabled={disabled} hidden={hidden}>\n              {/* No need to translate the options */}\n              {intlLabel.defaultMessage}\n            </SingleSelectOption>\n          );\n        })}\n      </SingleSelect>\n    </Field.Root>\n  );\n};\n","import { Flex, inputFocusStyle } from '@strapi/design-system';\nimport { styled } from 'styled-components';\n\nconst Wrapper = styled(Flex)`\n  position: relative;\n  align-items: stretch;\n\n  label {\n    border-radius: 4px;\n    max-width: 50%;\n    cursor: pointer;\n    user-select: none;\n    flex: 1;\n    border-radius: 4px;\n    border: 1px solid ${({ theme }) => theme.colors.neutral200};\n\n    ${inputFocusStyle()}\n  }\n\n  input {\n    position: absolute;\n    opacity: 0;\n  }\n\n  .option {\n    height: 100%;\n    border-radius: 4px;\n    will-change: transform, opacity;\n    background: ${({ theme }) => theme.colors.neutral0};\n\n    .checkmark {\n      position: relative;\n      display: block;\n      will-change: transform;\n      background: ${({ theme }) => theme.colors.neutral0};\n      width: ${({ theme }) => theme.spaces[5]};\n      height: ${({ theme }) => theme.spaces[5]};\n      border: solid 1px ${({ theme }) => theme.colors.neutral300};\n      border-radius: 50%;\n\n      &:before,\n      &:after {\n        content: '';\n        display: block;\n        border-radius: 50%;\n        width: ${({ theme }) => theme.spaces[3]};\n        height: ${({ theme }) => theme.spaces[3]};\n        position: absolute;\n        top: 3px;\n        left: 3px;\n      }\n\n      &:after {\n        transform: scale(0);\n        transition: inherit;\n        will-change: transform;\n      }\n    }\n  }\n\n  .container input:checked ~ div {\n    background: ${({ theme }) => theme.colors.primary100};\n    color: ${({ theme }) => theme.colors.primary600};\n    .checkmark {\n      border: solid 1px ${({ theme }) => theme.colors.primary600};\n      &::after {\n        background: ${({ theme }) => theme.colors.primary600};\n        transform: scale(1);\n      }\n    }\n  }\n`;\n\nexport { Wrapper };\n","import { Box, Flex, Typography } from '@strapi/design-system';\nimport { useIntl } from 'react-intl';\n\nimport { Wrapper } from './Styles';\n\nimport type { IntlLabel } from '../../types';\n\ninterface Radio {\n  title: IntlLabel;\n  description: IntlLabel;\n  value: any;\n}\n\ninterface CustomRadioGroupProps {\n  intlLabel: IntlLabel;\n  name: string;\n  onChange: (value: any) => void;\n  radios?: Radio[];\n  value?: string | boolean;\n}\n\nexport const CustomRadioGroup = ({\n  intlLabel,\n  name,\n  onChange,\n  radios = [],\n  value,\n}: CustomRadioGroupProps) => {\n  const { formatMessage } = useIntl();\n\n  return (\n    <Flex direction=\"column\" alignItems=\"stretch\" gap={2}>\n      <Typography variant=\"pi\" fontWeight=\"bold\" textColor=\"neutral800\" htmlFor={name} tag=\"label\">\n        {formatMessage(intlLabel)}\n      </Typography>\n      <Wrapper gap={4} alignItems=\"stretch\">\n        {radios.map((radio) => {\n          return (\n            <label htmlFor={radio.value.toString()} key={radio.value} className=\"container\">\n              <input\n                id={radio.value.toString()}\n                name={name}\n                className=\"option-input\"\n                checked={radio.value === value}\n                value={radio.value}\n                key={radio.value}\n                onChange={onChange}\n                type=\"radio\"\n              />\n              <Box className=\"option\" padding={4}>\n                <Flex>\n                  <Box paddingRight={4}>\n                    <span className=\"checkmark\" />\n                  </Box>\n                  <Flex direction=\"column\" alignItems=\"stretch\" gap={2}>\n                    <Typography fontWeight=\"bold\">{formatMessage(radio.title)}</Typography>\n                    <Typography variant=\"pi\" textColor=\"neutral600\">\n                      {formatMessage(radio.description)}\n                    </Typography>\n                  </Flex>\n                </Flex>\n              </Box>\n            </label>\n          );\n        })}\n      </Wrapper>\n    </Flex>\n  );\n};\n","import * as React from 'react';\n\nimport { IntlLabel } from '../types';\n\nimport { CustomRadioGroup } from './CustomRadioGroup';\n\ninterface BooleanRadioGroupProps {\n  intlLabel: IntlLabel;\n  name: string;\n  onChange: (value: any) => void;\n}\n\nexport const BooleanRadioGroup = ({\n  onChange,\n  name,\n  intlLabel,\n  ...rest\n}: BooleanRadioGroupProps) => {\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const checked = e.target.value !== 'false';\n\n    onChange({ target: { name, value: checked, type: 'boolean-radio-group' } });\n  };\n\n  return <CustomRadioGroup {...rest} name={name} onChange={handleChange} intlLabel={intlLabel} />;\n};\n","import { Box, Checkbox, Field, Flex, NumberInput, TextInput } from '@strapi/design-system';\nimport { useIntl } from 'react-intl';\n\nimport { IntlLabel } from '../types';\n\ninterface CheckboxWithNumberFieldProps {\n  error?: string;\n  intlLabel: IntlLabel;\n  modifiedData: Record<string, any>;\n  name: string;\n  onChange: (value: any) => void;\n  value?: any;\n}\n\nexport const CheckboxWithNumberField = ({\n  error,\n  intlLabel,\n  modifiedData,\n  name,\n  onChange,\n  value = null,\n}: CheckboxWithNumberFieldProps) => {\n  const { formatMessage } = useIntl();\n  const label = intlLabel.id\n    ? formatMessage(\n        { id: intlLabel.id, defaultMessage: intlLabel.defaultMessage },\n        { ...intlLabel.values }\n      )\n    : name;\n\n  const type = modifiedData.type === 'biginteger' ? 'text' : 'number';\n\n  const disabled = !modifiedData.type;\n  const errorMessage = error ? formatMessage({ id: error, defaultMessage: error }) : '';\n\n  return (\n    <Flex direction=\"column\" alignItems=\"stretch\" gap={2}>\n      <Checkbox\n        id={name}\n        name={name}\n        onCheckedChange={(value) => {\n          const initValue = type === 'text' ? '0' : 0;\n          const nextValue = value ? initValue : null;\n\n          onChange({ target: { name, value: nextValue } });\n        }}\n        checked={value !== null}\n      >\n        {label}\n      </Checkbox>\n      {value !== null && (\n        <Box paddingLeft={6} style={{ maxWidth: '200px' }}>\n          {type === 'text' ? (\n            <Field.Root error={errorMessage} name={name}>\n              <TextInput\n                aria-label={label}\n                disabled={disabled}\n                onChange={onChange}\n                value={value === null ? '' : value}\n              />\n              <Field.Error />\n            </Field.Root>\n          ) : (\n            <Field.Root error={errorMessage} name={name}>\n              <NumberInput\n                aria-label={label}\n                disabled={disabled}\n                onValueChange={(value: any) => {\n                  onChange({ target: { name, value: value ?? 0, type } });\n                }}\n                value={value || 0}\n              />\n              <Field.Error />\n            </Field.Root>\n          )}\n        </Box>\n      )}\n    </Flex>\n  );\n};\n","import { useNotification } from '@strapi/admin/strapi-admin';\nimport { useIntl } from 'react-intl';\n\nimport { getTrad } from '../utils';\n\nimport { CustomRadioGroup } from './CustomRadioGroup';\n\nimport type { IntlLabel } from '../types';\n\ninterface Radio {\n  title: IntlLabel;\n  description: IntlLabel;\n  value: any;\n}\n\ninterface ContentTypeRadioGroupProps {\n  intlLabel: IntlLabel;\n  name: string;\n  onChange: (value: any) => void;\n  radios?: Radio[];\n  value?: string | boolean;\n}\n\nexport const ContentTypeRadioGroup = ({ onChange, ...rest }: ContentTypeRadioGroupProps) => {\n  const { formatMessage } = useIntl();\n  const { toggleNotification } = useNotification();\n\n  const handleChange = (e: any) => {\n    toggleNotification({\n      type: 'info',\n      message: formatMessage({\n        id: getTrad('contentType.kind.change.warning'),\n        defaultMessage:\n          'You just changed the kind of a content type: API will be reset (routes, controllers, and services will be overwritten).',\n      }),\n    });\n\n    onChange(e);\n  };\n\n  return <CustomRadioGroup {...rest} onChange={handleChange} />;\n};\n","/**\n *\n * DraftAndPublishToggle\n *\n */\n\nimport { useState } from 'react';\n\nimport { ConfirmDialog } from '@strapi/admin/strapi-admin';\nimport { Button, Checkbox, CheckboxProps, Dialog, Field } from '@strapi/design-system';\nimport { useIntl } from 'react-intl';\n\nimport { getTrad } from '../utils';\n\nimport type { IntlLabel } from '../types';\n\ninterface Description {\n  id: string;\n  defaultMessage: string;\n  values?: Record<string, any>;\n}\n\ninterface DraftAndPublishToggleProps {\n  description?: Description;\n  disabled?: boolean;\n  intlLabel: IntlLabel;\n  isCreating: boolean;\n  name: string;\n  onChange: (value: { target: { name: string; value: boolean } }) => void;\n  value?: boolean;\n}\n\nexport const DraftAndPublishToggle = ({\n  description,\n  disabled = false,\n  intlLabel,\n  isCreating,\n  name,\n  onChange,\n  value = false,\n}: DraftAndPublishToggleProps) => {\n  const { formatMessage } = useIntl();\n  const [showWarning, setShowWarning] = useState(false);\n  const label = intlLabel.id\n    ? formatMessage(\n        { id: intlLabel.id, defaultMessage: intlLabel.defaultMessage },\n        { ...intlLabel.values }\n      )\n    : name;\n\n  const hint = description\n    ? formatMessage(\n        { id: description.id, defaultMessage: description.defaultMessage },\n        { ...description.values }\n      )\n    : '';\n\n  const handleConfirm = () => {\n    onChange({ target: { name, value: false } });\n\n    setShowWarning(false);\n  };\n\n  const handleChange: CheckboxProps['onCheckedChange'] = (checked) => {\n    if (!checked && !isCreating) {\n      setShowWarning(true);\n\n      return;\n    }\n\n    onChange({ target: { name, value: !!checked } });\n  };\n\n  return (\n    <>\n      <Field.Root hint={hint} name={name}>\n        <Checkbox checked={value} disabled={disabled} onCheckedChange={handleChange}>\n          {label}\n        </Checkbox>\n        <Field.Hint />\n      </Field.Root>\n\n      <Dialog.Root open={showWarning} onOpenChange={(isOpen) => setShowWarning(isOpen)}>\n        <ConfirmDialog\n          endAction={\n            <Button onClick={handleConfirm} variant=\"danger\" width=\"100%\" justifyContent=\"center\">\n              {formatMessage({\n                id: getTrad('popUpWarning.draft-publish.button.confirm'),\n                defaultMessage: 'Yes, disable',\n              })}\n            </Button>\n          }\n        >\n          {formatMessage({\n            id: getTrad('popUpWarning.draft-publish.message'),\n            defaultMessage: 'If you disable the draft & publish, your drafts will be deleted.',\n          })}\n        </ConfirmDialog>\n      </Dialog.Root>\n    </>\n  );\n};\n","/**\n *\n * FormModalEndActions\n *\n */\n\nimport { SyntheticEvent } from 'react';\n\nimport { Button, Flex } from '@strapi/design-system';\nimport { Plus } from '@strapi/icons';\nimport { useIntl } from 'react-intl';\n\nimport { getTrad } from '../utils';\n\ntype FormModalEndActionsProps = {\n  categoryName?: string;\n  deleteCategory: (categoryName: string) => void;\n  deleteComponent: () => void;\n  deleteContentType: () => void;\n  isAttributeModal: boolean;\n  isCustomFieldModal: boolean;\n  isComponentAttribute: boolean;\n  isComponentModal: boolean;\n  isComponentToDzModal: boolean;\n  isContentTypeModal: boolean;\n  isCreatingComponent: boolean;\n  isCreatingComponentAttribute: boolean;\n  isCreatingComponentInDz: boolean;\n  isCreatingComponentWhileAddingAField: boolean;\n  isCreatingContentType: boolean;\n  isCreatingDz: boolean;\n  isDzAttribute: boolean;\n  isEditingAttribute: boolean;\n  isEditingCategory: boolean;\n  isInFirstComponentStep: boolean;\n  onSubmitAddComponentAttribute: (e: SyntheticEvent, shouldContinue: boolean) => void;\n  onSubmitAddComponentToDz: (e: SyntheticEvent, shouldContinue: boolean) => void;\n  onSubmitCreateContentType: (e: SyntheticEvent, shouldContinue: boolean) => void;\n  onSubmitCreateComponent: (e: SyntheticEvent, shouldContinue: boolean) => void;\n  onSubmitCreateDz: (e: SyntheticEvent, shouldContinue: boolean) => void;\n  onSubmitEditAttribute: (e: SyntheticEvent, shouldContinue: boolean) => void;\n  onSubmitEditCategory: (e: SyntheticEvent) => void;\n  onSubmitEditComponent: (e: SyntheticEvent, shouldContinue: boolean) => void;\n  onSubmitEditContentType: (e: SyntheticEvent, shouldContinue: boolean) => void;\n  onSubmitEditCustomFieldAttribute: (e: SyntheticEvent, shouldContinue: boolean) => void;\n  onSubmitEditDz: (e: SyntheticEvent, shouldContinue: boolean) => void;\n  onClickFinish: () => void;\n};\n\nexport const FormModalEndActions = ({\n  categoryName,\n  deleteCategory,\n  deleteComponent,\n  deleteContentType,\n  isAttributeModal,\n  isCustomFieldModal,\n  isComponentAttribute,\n  isComponentToDzModal,\n  isContentTypeModal,\n  isCreatingComponent,\n  isCreatingComponentAttribute,\n  isCreatingComponentInDz,\n  isCreatingComponentWhileAddingAField,\n  isCreatingContentType,\n  isCreatingDz,\n  isComponentModal,\n  isDzAttribute,\n  isEditingAttribute,\n  isEditingCategory,\n  isInFirstComponentStep,\n  onSubmitAddComponentAttribute,\n  onSubmitAddComponentToDz,\n  onSubmitCreateContentType,\n  onSubmitCreateComponent,\n  onSubmitCreateDz,\n  onSubmitEditAttribute,\n  onSubmitEditCategory,\n  onSubmitEditComponent,\n  onSubmitEditContentType,\n  onSubmitEditCustomFieldAttribute,\n  onSubmitEditDz,\n  onClickFinish,\n}: FormModalEndActionsProps) => {\n  const { formatMessage } = useIntl();\n\n  if (isComponentToDzModal) {\n    if (isCreatingComponentInDz) {\n      return (\n        <Button\n          variant=\"secondary\"\n          type=\"submit\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n\n            onSubmitAddComponentToDz(e, true);\n          }}\n          startIcon={<Plus />}\n        >\n          {formatMessage({\n            id: getTrad('form.button.add-first-field-to-created-component'),\n            defaultMessage: 'Add first field to the component',\n          })}\n        </Button>\n      );\n    }\n\n    return (\n      <Button\n        variant=\"default\"\n        type=\"submit\"\n        onClick={(e: SyntheticEvent) => {\n          e.preventDefault();\n\n          onSubmitAddComponentToDz(e, false);\n        }}\n      >\n        {formatMessage({\n          id: 'global.finish',\n          defaultMessage: 'Finish',\n        })}\n      </Button>\n    );\n  }\n\n  if (isAttributeModal && isDzAttribute && !isCreatingDz) {\n    return (\n      <Button\n        variant=\"default\"\n        type=\"submit\"\n        onClick={(e: SyntheticEvent) => {\n          e.preventDefault();\n\n          onClickFinish();\n          onSubmitEditDz(e, false);\n        }}\n      >\n        {formatMessage({\n          id: 'global.finish',\n          defaultMessage: 'Finish',\n        })}\n      </Button>\n    );\n  }\n\n  if (isAttributeModal && isDzAttribute && isCreatingDz) {\n    return (\n      <>\n        <Button\n          variant=\"secondary\"\n          type=\"submit\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n\n            onSubmitCreateDz(e, true);\n          }}\n          startIcon={<Plus />}\n        >\n          {formatMessage({\n            id: getTrad('form.button.add-components-to-dynamiczone'),\n            defaultMessage: 'Add components to the zone',\n          })}\n        </Button>\n        {/* // TO FIX fix doesnt close the modal */}\n        {/* <Button\n          variant=\"default\"\n          type=\"button\"\n          onClick={e => {\n            e.preventDefault();\n\n            onSubmitCreateDz(e, false);\n          }}\n        >\n          {formatMessage({\n            id: 'global.finish',\n            defaultMessage: 'Finish',\n          })}\n        </Button> */}\n      </>\n    );\n  }\n\n  if (isAttributeModal && isComponentAttribute) {\n    if (isInFirstComponentStep) {\n      return (\n        <Button\n          variant=\"secondary\"\n          type=\"submit\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n\n            onSubmitAddComponentAttribute(e, true);\n          }}\n        >\n          {isCreatingComponentAttribute\n            ? formatMessage({\n                id: getTrad('form.button.configure-component'),\n                defaultMessage: 'Configure the component',\n              })\n            : formatMessage({\n                id: getTrad('form.button.select-component'),\n                defaultMessage: 'Configure the component',\n              })}\n        </Button>\n      );\n    }\n\n    return (\n      <Flex gap={2}>\n        <Button\n          variant=\"secondary\"\n          type=\"submit\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n\n            onSubmitAddComponentAttribute(e, true);\n          }}\n          startIcon={<Plus />}\n        >\n          {isCreatingComponentWhileAddingAField\n            ? formatMessage({\n                id: getTrad('form.button.add-first-field-to-created-component'),\n                defaultMessage: 'Add first field to the component',\n              })\n            : formatMessage({\n                id: getTrad('form.button.add-field'),\n                defaultMessage: 'Add another field',\n              })}\n        </Button>\n        <Button\n          variant=\"default\"\n          type=\"button\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n\n            onClickFinish();\n            onSubmitAddComponentAttribute(e, false);\n          }}\n        >\n          {formatMessage({\n            id: 'global.finish',\n            defaultMessage: 'Finish',\n          })}\n        </Button>\n      </Flex>\n    );\n  }\n\n  if (isAttributeModal && !isComponentAttribute && !isDzAttribute) {\n    return (\n      <Flex gap={2}>\n        <Button\n          type={isEditingAttribute ? 'button' : 'submit'}\n          variant=\"secondary\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n\n            onSubmitEditAttribute(e, true);\n          }}\n          startIcon={<Plus />}\n        >\n          {formatMessage({\n            id: getTrad('form.button.add-field'),\n            defaultMessage: 'Add another field',\n          })}\n        </Button>\n        <Button\n          type={isEditingAttribute ? 'submit' : 'button'}\n          variant=\"default\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n\n            onClickFinish();\n            onSubmitEditAttribute(e, false);\n          }}\n        >\n          {formatMessage({\n            id: 'global.finish',\n            defaultMessage: 'Finish',\n          })}\n        </Button>\n      </Flex>\n    );\n  }\n\n  if (isContentTypeModal) {\n    return (\n      <Flex gap={2}>\n        {!isCreatingContentType && (\n          <>\n            <Button\n              type=\"button\"\n              variant=\"danger\"\n              onClick={(e: SyntheticEvent) => {\n                e.preventDefault();\n                deleteContentType();\n              }}\n            >\n              {formatMessage({\n                id: 'global.delete',\n                defaultMessage: 'Delete',\n              })}\n            </Button>\n            <Button\n              type=\"submit\"\n              variant=\"default\"\n              onClick={(e: SyntheticEvent) => {\n                e.preventDefault();\n\n                onSubmitEditContentType(e, false);\n              }}\n            >\n              {formatMessage({\n                id: 'global.finish',\n                defaultMessage: 'Finish',\n              })}\n            </Button>\n          </>\n        )}\n        {isCreatingContentType && (\n          <Button\n            type=\"submit\"\n            variant=\"secondary\"\n            onClick={(e: SyntheticEvent) => {\n              e.preventDefault();\n\n              onSubmitCreateContentType(e, true);\n            }}\n          >\n            {formatMessage({\n              id: 'global.continue',\n              defaultMessage: 'Continue',\n            })}\n          </Button>\n        )}\n      </Flex>\n    );\n  }\n\n  if (isComponentModal) {\n    return (\n      <Flex gap={2}>\n        {!isCreatingComponent && (\n          <>\n            <Button\n              type=\"button\"\n              variant=\"danger\"\n              onClick={(e: SyntheticEvent) => {\n                e.preventDefault();\n                deleteComponent();\n              }}\n            >\n              {formatMessage({\n                id: 'global.delete',\n                defaultMessage: 'Delete',\n              })}\n            </Button>\n            <Button\n              type=\"submit\"\n              variant=\"default\"\n              onClick={(e: SyntheticEvent) => {\n                e.preventDefault();\n\n                onSubmitEditComponent(e, false);\n              }}\n            >\n              {formatMessage({\n                id: 'global.finish',\n                defaultMessage: 'Finish',\n              })}\n            </Button>\n          </>\n        )}\n        {isCreatingComponent && (\n          <Button\n            type=\"submit\"\n            variant=\"secondary\"\n            onClick={(e: SyntheticEvent) => {\n              e.preventDefault();\n\n              onSubmitCreateComponent(e, true);\n            }}\n          >\n            {formatMessage({\n              id: 'global.continue',\n              defaultMessage: 'Continue',\n            })}\n          </Button>\n        )}\n      </Flex>\n    );\n  }\n\n  if (isEditingCategory) {\n    return (\n      <Flex gap={2}>\n        <Button\n          type=\"button\"\n          variant=\"danger\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n            if (categoryName) {\n              deleteCategory(categoryName);\n            }\n          }}\n        >\n          {formatMessage({\n            id: 'global.delete',\n            defaultMessage: 'Delete',\n          })}\n        </Button>\n        <Button\n          type=\"submit\"\n          variant=\"default\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n\n            onSubmitEditCategory(e);\n          }}\n        >\n          {formatMessage({\n            id: 'global.finish',\n            defaultMessage: 'finish',\n          })}\n        </Button>\n      </Flex>\n    );\n  }\n\n  if (isCustomFieldModal) {\n    return (\n      <Flex gap={2}>\n        <Button\n          type={isEditingAttribute ? 'button' : 'submit'}\n          variant=\"secondary\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n\n            onSubmitEditCustomFieldAttribute(e, true);\n          }}\n          startIcon={<Plus />}\n        >\n          {formatMessage({\n            id: getTrad('form.button.add-field'),\n            defaultMessage: 'Add another field',\n          })}\n        </Button>\n        <Button\n          type={isEditingAttribute ? 'submit' : 'button'}\n          variant=\"default\"\n          onClick={(e: SyntheticEvent) => {\n            e.preventDefault();\n\n            onClickFinish();\n            onSubmitEditCustomFieldAttribute(e, false);\n          }}\n        >\n          {formatMessage({\n            id: 'global.finish',\n            defaultMessage: 'Finish',\n          })}\n        </Button>\n      </Flex>\n    );\n  }\n\n  return null;\n};\n","/**\n *\n * FormModalHeader\n *\n */\nimport { Box, Flex, Breadcrumbs, Crumb, Link, Modal } from '@strapi/design-system';\nimport { ArrowLeft } from '@strapi/icons';\nimport upperFirst from 'lodash/upperFirst';\nimport { useIntl } from 'react-intl';\n\nimport { useDataManager } from '../hooks/useDataManager';\nimport { useFormModalNavigation } from '../hooks/useFormModalNavigation';\nimport { getTrad } from '../utils';\n\nimport { AttributeIcon, IconByType } from './AttributeIcon';\n\nimport type { SchemaType } from '../types';\nimport type { Internal } from '@strapi/types';\n\ninterface Header {\n  label: string;\n  info?: { category: string; name: string };\n}\n\ninterface FormModalHeaderProps {\n  actionType?: string | null;\n  attributeName: string;\n  attributeType: IconByType;\n  categoryName: string;\n  contentTypeKind: IconByType;\n  dynamicZoneTarget: string;\n  forTarget: SchemaType;\n  modalType: string | null;\n  targetUid: Internal.UID.Schema;\n  customFieldUid?: string | null;\n  showBackLink?: boolean;\n}\n\nexport const FormModalHeader = ({\n  actionType = null,\n  attributeName,\n  attributeType,\n  categoryName,\n  contentTypeKind,\n  dynamicZoneTarget,\n  forTarget,\n  modalType = null,\n  targetUid,\n  customFieldUid = null,\n  showBackLink = false,\n}: FormModalHeaderProps) => {\n  const { formatMessage } = useIntl();\n  const { modifiedData } = useDataManager();\n  const { onOpenModalAddField } = useFormModalNavigation();\n\n  let icon: IconByType = 'component';\n  let headers: Header[] = [];\n\n  const schema = modifiedData?.[forTarget]?.[targetUid] || modifiedData?.[forTarget] || null;\n  const displayName = schema?.schema.displayName;\n\n  if (modalType === 'contentType') {\n    icon = contentTypeKind;\n  }\n\n  if (['component', 'editCategory'].includes(modalType || '')) {\n    icon = 'component';\n  }\n\n  const isCreatingMainSchema = ['component', 'contentType'].includes(modalType || '');\n\n  if (isCreatingMainSchema) {\n    let headerId = getTrad(`modalForm.component.header-${actionType}`);\n\n    if (modalType === 'contentType') {\n      headerId = getTrad(`modalForm.${contentTypeKind}.header-create`);\n    }\n\n    if (actionType === 'edit') {\n      headerId = getTrad(`modalForm.header-edit`);\n    }\n\n    return (\n      <Modal.Header>\n        <Flex>\n          <Box>\n            <AttributeIcon type={icon} />\n          </Box>\n          <Box paddingLeft={3}>\n            <Modal.Title>{formatMessage({ id: headerId }, { name: displayName })}</Modal.Title>\n          </Box>\n        </Flex>\n      </Modal.Header>\n    );\n  }\n\n  headers = [\n    {\n      label: displayName,\n      info: { category: schema?.category || null, name: schema?.schema.displayName },\n    },\n  ];\n\n  if (modalType === 'chooseAttribute') {\n    icon = ['component', 'components'].includes(forTarget) ? 'component' : schema.schema.kind;\n  }\n\n  if (modalType === 'addComponentToDynamicZone') {\n    icon = 'dynamiczone';\n    headers.push({ label: dynamicZoneTarget });\n  }\n\n  if (modalType === 'attribute' || modalType === 'customField') {\n    icon = attributeType;\n    headers.push({ label: attributeName });\n  }\n\n  if (modalType === 'editCategory') {\n    const label = formatMessage({\n      id: getTrad('modalForm.header.categories'),\n      defaultMessage: 'Categories',\n    });\n\n    headers = [{ label }, { label: categoryName }];\n  }\n\n  return (\n    <Modal.Header>\n      <Flex gap={3}>\n        {showBackLink && (\n          // This is a workaround and should use the LinkButton with a variant that currently doesn't exist\n          <Link\n            aria-label={formatMessage({\n              id: getTrad('modalForm.header.back'),\n              defaultMessage: 'Back',\n            })}\n            startIcon={<ArrowLeft />}\n            onClick={() => onOpenModalAddField({ forTarget, targetUid })}\n            href=\"#back\"\n            isExternal={false}\n          />\n        )}\n        <AttributeIcon type={icon} customField={customFieldUid} />\n\n        <Breadcrumbs label={headers.map(({ label }) => label).join(',')}>\n          {headers.map(({ label, info }, index, arr) => {\n            label = upperFirst(label);\n\n            if (!label) {\n              return null;\n            }\n\n            const key = `${label}.${index}`;\n\n            if (info?.category) {\n              label = `${label} (${upperFirst(info.category)} - ${upperFirst(info.name)})`;\n            }\n\n            return (\n              <Crumb isCurrent={index === arr.length - 1} key={key}>\n                {label}\n              </Crumb>\n            );\n          })}\n        </Breadcrumbs>\n      </Flex>\n    </Modal.Header>\n  );\n};\n","import { StrapiAppContextValue } from '@strapi/admin/strapi-admin';\nimport { Flex, Typography } from '@strapi/design-system';\nimport upperFirst from 'lodash/upperFirst';\nimport { useIntl } from 'react-intl';\n\nimport { getTrad } from '../utils';\n\nimport type { SchemaType } from '../types';\n\ntype ModalTitleProps = {\n  forTarget?: SchemaType;\n  step?: string;\n  kind?: string;\n  modalType?: string;\n  actionType?: string;\n};\n\nexport const getModalTitleSubHeader = ({\n  modalType,\n  forTarget,\n  kind,\n  actionType,\n  step,\n}: ModalTitleProps) => {\n  switch (modalType) {\n    case 'chooseAttribute':\n      return getTrad(\n        `modalForm.sub-header.chooseAttribute.${\n          forTarget?.includes('component') ? 'component' : kind || 'collectionType'\n        }`\n      );\n    case 'attribute': {\n      return getTrad(\n        `modalForm.sub-header.attribute.${actionType}${\n          step !== 'null' && step !== null && actionType !== 'edit' ? '.step' : ''\n        }`\n      );\n    }\n    case 'customField': {\n      return getTrad(`modalForm.sub-header.attribute.${actionType}`);\n    }\n    case 'addComponentToDynamicZone':\n      return getTrad('modalForm.sub-header.addComponentToDynamicZone');\n    default:\n      return getTrad('configurations');\n  }\n};\n\ntype FormModalSubHeaderProps = {\n  actionType: string;\n  modalType: string;\n  forTarget: SchemaType;\n  kind?: string;\n  step?: string;\n  attributeType: string;\n  attributeName: string;\n  customField?: ReturnType<StrapiAppContextValue['customFields']['get']>;\n};\n\nexport const FormModalSubHeader = ({\n  actionType,\n  modalType,\n  forTarget,\n  kind,\n  step,\n  attributeType,\n  attributeName,\n  customField,\n}: FormModalSubHeaderProps) => {\n  const { formatMessage } = useIntl();\n  const intlLabel =\n    modalType === 'customField'\n      ? customField?.intlLabel\n      : { id: getTrad(`attribute.${attributeType}`) };\n\n  return (\n    <Flex direction=\"column\" alignItems=\"flex-start\" paddingBottom={1} gap={1}>\n      <Typography tag=\"h2\" variant=\"beta\">\n        {formatMessage(\n          {\n            id: getModalTitleSubHeader({\n              actionType,\n              forTarget,\n              kind,\n              step,\n              modalType,\n            }),\n            defaultMessage: 'Add new field',\n          },\n          {\n            type: intlLabel ? upperFirst(formatMessage(intlLabel)) : '',\n            name: upperFirst(attributeName),\n            step,\n          }\n        )}\n      </Typography>\n      <Typography variant=\"pi\" textColor=\"neutral600\">\n        {formatMessage({\n          id: getTrad(`attribute.${attributeType}.description`),\n          defaultMessage: 'A type for modeling data',\n        })}\n      </Typography>\n    </Flex>\n  );\n};\n","import * as Icons from '@strapi/icons';\nimport * as Symbols from '@strapi/icons/symbols';\n\nexport type Icon = (typeof Icons)[keyof typeof Icons] | (typeof Symbols)[keyof typeof Symbols];\n\nconst COMPONENT_ICONS: Record<string, Icon> = {\n  alien: Icons.Alien,\n  apps: Icons.GridNine,\n  archive: Icons.Archive,\n  arrowDown: Icons.ArrowDown,\n  arrowLeft: Icons.ArrowLeft,\n  arrowRight: Icons.ArrowRight,\n  arrowUp: Icons.ArrowUp,\n  attachment: Icons.Paperclip,\n  bell: Icons.Bell,\n  bold: Icons.Bold,\n  book: Icons.Book,\n  briefcase: Icons.Briefcase,\n  brush: Icons.PaintBrush,\n  bulletList: Icons.BulletList,\n  calendar: Icons.Calendar,\n  car: Icons.Car,\n  cast: Icons.Cast,\n  chartBubble: Icons.ChartBubble,\n  chartCircle: Icons.ChartCircle,\n  chartPie: Icons.ChartPie,\n  check: Icons.Check,\n  clock: Icons.Clock,\n  cloud: Icons.Cloud,\n  code: Icons.Code,\n  cog: Icons.Cog,\n  collapse: Icons.Collapse,\n  command: Icons.Command,\n  connector: Icons.Faders,\n  crop: Icons.Crop,\n  crown: Icons.Crown,\n  cup: Icons.Coffee,\n  cursor: Icons.Cursor,\n  dashboard: Icons.SquaresFour,\n  database: Icons.Database,\n  discuss: Icons.Discuss,\n  doctor: Icons.Stethoscope,\n  earth: Icons.Earth,\n  emotionHappy: Icons.EmotionHappy,\n  emotionUnhappy: Icons.EmotionUnhappy,\n  envelop: Icons.Mail,\n  exit: Icons.SignOut,\n  expand: Icons.Expand,\n  eye: Icons.Eye,\n  feather: Icons.Feather,\n  file: Icons.File,\n  fileError: Icons.FileError,\n  filePdf: Icons.FilePdf,\n  filter: Icons.Filter,\n  folder: Icons.Folder,\n  gate: Icons.CastleTurret,\n  gift: Icons.Gift,\n  globe: Icons.Globe,\n  grid: Icons.GridFour,\n  handHeart: Icons.HandHeart,\n  hashtag: Icons.Hashtag,\n  headphone: Icons.Headphones,\n  heart: Icons.Heart,\n  house: Icons.House,\n  information: Icons.Information,\n  italic: Icons.Italic,\n  key: Icons.Key,\n  landscape: Icons.Images,\n  layer: Icons.ListPlus,\n  layout: Icons.Layout,\n  lightbulb: Icons.Lightbulb,\n  link: Icons.Link,\n  lock: Icons.Lock,\n  magic: Icons.Magic,\n  manyToMany: Icons.ManyToMany,\n  manyToOne: Icons.ManyToOne,\n  manyWays: Icons.ManyWays,\n  medium: Symbols.Medium,\n  message: Icons.Message,\n  microphone: Icons.Microphone,\n  monitor: Icons.Monitor,\n  moon: Icons.Moon,\n  music: Icons.MusicNotes,\n  oneToMany: Icons.OneToMany,\n  oneToOne: Icons.OneToOne,\n  oneWay: Icons.OneWay,\n  paint: Icons.PaintBrush,\n  paintBrush: Icons.PaintBrush,\n  paperPlane: Icons.PaperPlane,\n  pencil: Icons.Pencil,\n  phone: Icons.Phone,\n  picture: Icons.Image,\n  pin: Icons.Pin,\n  pinMap: Icons.PinMap,\n  plane: Icons.Plane,\n  play: Icons.Play,\n  plus: Icons.Plus,\n  priceTag: Icons.PriceTag,\n  puzzle: Icons.PuzzlePiece,\n  question: Icons.Question,\n  quote: Icons.Quotes,\n  refresh: Icons.ArrowClockwise,\n  restaurant: Icons.Restaurant,\n  rocket: Icons.Rocket,\n  rotate: Icons.ArrowsCounterClockwise,\n  scissors: Icons.Scissors,\n  search: Icons.Search,\n  seed: Icons.Plant,\n  server: Icons.Server,\n  shield: Icons.Shield,\n  shirt: Icons.Shirt,\n  shoppingCart: Icons.ShoppingCart,\n  slideshow: Icons.PresentationChart,\n  stack: Icons.Stack,\n  star: Icons.Star,\n  store: Icons.Store,\n  strikeThrough: Icons.StrikeThrough,\n  sun: Icons.Sun,\n  television: Icons.Television,\n  thumbDown: Icons.ThumbDown,\n  thumbUp: Icons.ThumbUp,\n  train: Icons.Train,\n  twitter: Symbols.X,\n  typhoon: Icons.Typhoon,\n  underline: Icons.Underline,\n  user: Icons.User,\n  volumeMute: Icons.VolumeMute,\n  volumeUp: Icons.VolumeUp,\n  walk: Icons.Walk,\n  wheelchair: Icons.Wheelchair,\n  write: Icons.Feather,\n};\n\nexport { COMPONENT_ICONS };\n","import { useEffect, useRef, useState } from 'react';\n\nimport {\n  Box,\n  Field,\n  Flex,\n  IconButton,\n  inputFocusStyle,\n  Searchbar,\n  Tooltip,\n  Typography,\n  VisuallyHidden,\n} from '@strapi/design-system';\nimport { Search, Trash } from '@strapi/icons';\nimport { useIntl } from 'react-intl';\nimport { styled } from 'styled-components';\n\nimport { getTrad } from '../../utils';\n\nimport { COMPONENT_ICONS } from './constants';\n\nimport type { IntlLabel } from '../../types';\n\nconst IconPickerWrapper = styled(Flex)`\n  label {\n    ${inputFocusStyle()}\n    border-radius: ${({ theme }) => theme.borderRadius};\n    border: 1px solid ${({ theme }) => theme.colors.neutral100};\n  }\n`;\n\ntype Icons = keyof typeof COMPONENT_ICONS;\n\ninterface IconPickProps {\n  iconKey: Icons;\n  name: string;\n  onChange: (value: any) => void;\n  isSelected: boolean;\n  ariaLabel: string;\n}\n\nconst IconPick = ({ iconKey, name, onChange, isSelected, ariaLabel }: IconPickProps) => {\n  const Icon = COMPONENT_ICONS[iconKey];\n\n  return (\n    <Field.Root name={name} required={false}>\n      <Field.Label>\n        <VisuallyHidden>\n          {ariaLabel}\n          <Field.Input\n            type=\"radio\"\n            checked={isSelected}\n            onChange={onChange}\n            value={iconKey}\n            aria-checked={isSelected}\n          />\n        </VisuallyHidden>\n        <Flex\n          padding={2}\n          cursor=\"pointer\"\n          hasRadius\n          background={isSelected ? 'primary200' : undefined}\n        >\n          <Icon fill={isSelected ? 'primary600' : 'neutral300'} />\n        </Flex>\n      </Field.Label>\n    </Field.Root>\n  );\n};\n\nexport interface IconPickerProps {\n  intlLabel: IntlLabel;\n  name: string;\n  onChange: (value: { target: { name: string; value: string } }) => void;\n  value?: string;\n}\n\nexport const IconPicker = ({ intlLabel, name, onChange, value = '' }: IconPickerProps) => {\n  const { formatMessage } = useIntl();\n  const [showSearch, setShowSearch] = useState(false);\n  const [search, setSearch] = useState('');\n  const allIcons = Object.keys(COMPONENT_ICONS) as Icons[];\n  const [icons, setIcons] = useState(allIcons);\n  const searchIconRef = useRef(null);\n  const searchBarRef = useRef(null);\n\n  const toggleSearch = () => {\n    setShowSearch(!showSearch);\n  };\n\n  const onChangeSearch = ({ target: { value } }: { target: { value: string } }) => {\n    setSearch(value);\n    setIcons(() => allIcons.filter((icon) => icon.toLowerCase().includes(value.toLowerCase())));\n  };\n\n  const onClearSearch = () => {\n    toggleSearch();\n    setSearch('');\n    setIcons(allIcons);\n  };\n\n  const removeIconSelected = () => {\n    onChange({ target: { name, value: '' } });\n  };\n\n  useEffect(() => {\n    if (showSearch) {\n      (searchBarRef.current as unknown as HTMLInputElement)?.focus();\n    }\n  }, [showSearch]);\n\n  return (\n    <>\n      <Flex justifyContent=\"space-between\" paddingBottom={2}>\n        <Typography variant=\"pi\" fontWeight=\"bold\" textColor=\"neutral800\" tag=\"label\">\n          {formatMessage(intlLabel)}\n        </Typography>\n        <Flex gap={1}>\n          {showSearch ? (\n            <Searchbar\n              ref={searchBarRef}\n              name=\"searchbar\"\n              placeholder={formatMessage({\n                id: getTrad('ComponentIconPicker.search.placeholder'),\n                defaultMessage: 'Search for an icon',\n              })}\n              onBlur={() => {\n                if (!search) {\n                  toggleSearch();\n                }\n              }}\n              onChange={onChangeSearch}\n              value={search}\n              onClear={onClearSearch}\n              clearLabel={formatMessage({\n                id: getTrad('IconPicker.search.clear.label'),\n                defaultMessage: 'Clear the icon search',\n              })}\n            >\n              {formatMessage({\n                id: getTrad('IconPicker.search.placeholder.label'),\n                defaultMessage: 'Search for an icon',\n              })}\n            </Searchbar>\n          ) : (\n            <IconButton\n              ref={searchIconRef}\n              onClick={toggleSearch}\n              withTooltip={false}\n              label={formatMessage({\n                id: getTrad('IconPicker.search.button.label'),\n                defaultMessage: 'Search icon button',\n              })}\n              variant=\"ghost\"\n            >\n              <Search />\n            </IconButton>\n          )}\n          {value && (\n            <Tooltip\n              label={formatMessage({\n                id: getTrad('IconPicker.remove.tooltip'),\n                defaultMessage: 'Remove the selected icon',\n              })}\n            >\n              <IconButton\n                onClick={removeIconSelected}\n                withTooltip={false}\n                label={formatMessage({\n                  id: getTrad('IconPicker.remove.button'),\n                  defaultMessage: 'Remove the selected icon',\n                })}\n                variant=\"ghost\"\n              >\n                <Trash />\n              </IconButton>\n            </Tooltip>\n          )}\n        </Flex>\n      </Flex>\n      <IconPickerWrapper\n        position=\"relative\"\n        padding={1}\n        background=\"neutral100\"\n        hasRadius\n        wrap=\"wrap\"\n        gap={2}\n        maxHeight=\"126px\"\n        overflow=\"auto\"\n        textAlign=\"center\"\n      >\n        {icons.length > 0 ? (\n          icons.map((iconKey) => (\n            <IconPick\n              key={iconKey}\n              iconKey={iconKey}\n              name={name}\n              onChange={onChange}\n              isSelected={iconKey === value}\n              ariaLabel={formatMessage(\n                {\n                  id: getTrad('IconPicker.icon.label'),\n                  defaultMessage: 'Select {icon} icon',\n                },\n                { icon: iconKey }\n              )}\n            />\n          ))\n        ) : (\n          <Box padding={4} grow={2}>\n            <Typography variant=\"delta\" textColor=\"neutral600\" textAlign=\"center\">\n              {formatMessage({\n                id: getTrad('IconPicker.emptyState.label'),\n                defaultMessage: 'No icon found',\n              })}\n            </Typography>\n          </Box>\n        )}\n      </IconPickerWrapper>\n    </>\n  );\n};\n","import { useEffect, useRef } from 'react';\n\nimport { Field, TextInput } from '@strapi/design-system';\nimport pluralize from 'pluralize';\nimport { useIntl } from 'react-intl';\n\nimport { nameToSlug } from '../utils/nameToSlug';\n\nimport type { IntlLabel } from '../types';\n\ninterface Description {\n  id: string;\n  defaultMessage: string;\n  values?: Record<string, any>;\n}\n\ninterface PluralNameProps {\n  description?: Description;\n  error?: string;\n  intlLabel: IntlLabel;\n  modifiedData: Record<string, any>;\n  name: string;\n  onChange: (value: { target: { name: string; value: string } }) => void;\n  value?: string;\n}\n\nexport const PluralName = ({\n  description,\n  error,\n  intlLabel,\n  modifiedData,\n  name,\n  onChange,\n  value,\n}: PluralNameProps) => {\n  const { formatMessage } = useIntl();\n  const onChangeRef = useRef(onChange);\n  const displayName = modifiedData?.displayName || '';\n\n  useEffect(() => {\n    if (displayName) {\n      const value = nameToSlug(displayName);\n\n      try {\n        const plural = pluralize(value, 2);\n        onChangeRef.current({ target: { name, value: plural } });\n      } catch (err) {\n        onChangeRef.current({ target: { name, value } });\n      }\n    } else {\n      onChangeRef.current({ target: { name, value: '' } });\n    }\n  }, [displayName, name]);\n\n  const errorMessage = error ? formatMessage({ id: error, defaultMessage: error }) : '';\n  const hint = description\n    ? formatMessage(\n        { id: description.id, defaultMessage: description.defaultMessage },\n        { ...description.values }\n      )\n    : '';\n  const label = formatMessage(intlLabel);\n\n  return (\n    <Field.Root error={errorMessage} hint={hint} name={name}>\n      <Field.Label>{label}</Field.Label>\n      <TextInput onChange={onChange} value={value || ''} />\n      <Field.Error />\n    </Field.Root>\n  );\n};\n","export const parseDateValue = (value: unknown): Date | undefined => {\n  if (value instanceof Date && isValidDate(value)) {\n    return value;\n  }\n\n  if (typeof value === 'string' || typeof value === 'number') {\n    const date = new Date(value);\n    if (isValidDate(date)) {\n      return date;\n    }\n  }\n};\n\nconst isValidDate = (date: Date): boolean => !isNaN(date.getTime());\n","type TimeChangeHandler = (params: {\n  target: { name: string; value: string | undefined; type: string };\n}) => void;\n\ntype TimeChangeParams = {\n  value?: string;\n  onChange: TimeChangeHandler;\n  name: string;\n  type: string;\n};\n\n// The backend sends a value which has the following format: '00:45:00.000'\n// but the time picker only supports hours & minutes so we need to mutate the value\nconst removeSeconds = (time: string): string => {\n  const [hours, minutes] = time.split(':');\n  return `${hours}:${minutes}`;\n};\n\n// we need to send back the value with the same '00:45:00.000' format\nconst addSecondsAndMilliseconds = (time: string): string => {\n  return time.split(':').length === 2 ? `${time}:00.000` : time;\n};\n\nconst formatTimeForInput = (value?: string): string | undefined => {\n  if (!value) return;\n  return value.split(':').length > 2 ? removeSeconds(value) : value;\n};\n\nconst formatTimeForOutput = (value?: string): string | undefined => {\n  if (!value) return undefined;\n  return addSecondsAndMilliseconds(value);\n};\n\nexport const handleTimeChange = ({ value }: TimeChangeParams): string | undefined => {\n  const formattedInputTime = formatTimeForInput(value);\n\n  return formattedInputTime;\n};\n\nexport const handleTimeChangeEvent = (\n  onChange: TimeChangeHandler,\n  name: string,\n  type: string,\n  time?: string\n): void => {\n  const formattedOutputTime = formatTimeForOutput(time);\n\n  onChange({\n    target: {\n      name,\n      value: formattedOutputTime,\n      type,\n    },\n  });\n};\n","/**\n * TODO: we should be using the FormRenderer from the admin to do this,\n * but the CTB has no tests or types, so we can't refactor it safely.\n * So we're just adding this to the tech debt.\n */\n\nimport * as React from 'react';\n\nimport {\n  Checkbox,\n  DatePicker,\n  DateTimePicker,\n  Field,\n  JSONInput,\n  NumberInput,\n  SingleSelect,\n  SingleSelectOption,\n  Textarea,\n  TextInput,\n  TimePicker,\n  Toggle,\n} from '@strapi/design-system';\nimport { Eye, EyeStriked } from '@strapi/icons';\nimport formatISO from 'date-fns/formatISO';\nimport isEqual from 'lodash/isEqual';\nimport { type MessageDescriptor, type PrimitiveType, useIntl } from 'react-intl';\n\nimport { parseDateValue } from '../utils/parseDateValue';\nimport { handleTimeChange, handleTimeChangeEvent } from '../utils/timeFormat';\n\nimport type { Schema } from '@strapi/types';\n\ninterface TranslationMessage extends MessageDescriptor {\n  values?: Record<string, PrimitiveType>;\n}\n\ninterface InputOption {\n  metadatas: {\n    intlLabel: TranslationMessage;\n    disabled: boolean;\n    hidden: boolean;\n  };\n  key: string;\n  value: string;\n}\n\ninterface CustomInputProps<TAttribute extends Schema.Attribute.AnyAttribute>\n  extends Omit<GenericInputProps<TAttribute>, 'customInputs'> {\n  ref?: React.Ref<HTMLElement>;\n  hint?: string | React.JSX.Element | (string | React.JSX.Element)[];\n}\n\ninterface GenericInputProps<\n  TAttribute extends Schema.Attribute.AnyAttribute = Schema.Attribute.AnyAttribute,\n> {\n  attribute?: TAttribute;\n  autoComplete?: string;\n  customInputs?: Record<string, React.ComponentType<CustomInputProps<TAttribute>>>;\n  description?: TranslationMessage;\n  disabled?: boolean;\n  error?: string | TranslationMessage;\n  intlLabel: TranslationMessage;\n  labelAction?: React.ReactNode;\n  name: string;\n  onChange: (\n    payload: {\n      target: {\n        name: string;\n        value: Schema.Attribute.Value<TAttribute>;\n        type?: string;\n      };\n    },\n    shouldSetInitialValue?: boolean\n  ) => void;\n  options?: InputOption[];\n  placeholder?: TranslationMessage;\n  required?: boolean;\n  step?: number;\n  type: string;\n  // TODO: The value depends on the input type, too complicated to handle all cases here\n  value?: Schema.Attribute.Value<TAttribute>;\n  isNullable?: boolean;\n}\n\nconst GenericInput = ({\n  autoComplete,\n  customInputs,\n  description,\n  disabled,\n  intlLabel,\n  labelAction,\n  error,\n  name,\n  onChange,\n  options = [],\n  placeholder,\n  required,\n  step,\n  type,\n  value: defaultValue,\n  isNullable,\n  attribute,\n  ...rest\n}: GenericInputProps) => {\n  const { formatMessage } = useIntl();\n\n  // TODO: Workaround to get the field hint values if they exist on the type\n  const getFieldHintValue = (\n    attribute?: Schema.Attribute.AnyAttribute,\n    key?: keyof FieldSchema\n  ) => {\n    if (!attribute) return;\n\n    if (key === 'minLength' && key in attribute) {\n      return attribute[key];\n    }\n\n    if (key === 'maxLength' && key in attribute) {\n      return attribute[key];\n    }\n\n    if (key === 'max' && key in attribute) {\n      return attribute[key];\n    }\n\n    if (key === 'min' && key in attribute) {\n      return attribute[key];\n    }\n  };\n\n  const { hint } = useFieldHint({\n    description,\n    fieldSchema: {\n      minLength: getFieldHintValue(attribute, 'minLength'),\n      maxLength: getFieldHintValue(attribute, 'maxLength'),\n      max: getFieldHintValue(attribute, 'max'),\n      min: getFieldHintValue(attribute, 'min'),\n    },\n    type: attribute?.type || type,\n  });\n\n  const [showPassword, setShowPassword] = React.useState(false);\n\n  const CustomInput = customInputs ? customInputs[type] : null;\n\n  // the API always returns null, which throws an error in React,\n  // therefore we cast this case to undefined\n  const value = defaultValue ?? undefined;\n\n  /*\n   TODO: ideally we should pass in `defaultValue` and `value` for\n   inputs, in order to make them controlled components. This variable\n   acts as a fallback for now, to prevent React errors in devopment mode\n\n   See: https://github.com/strapi/strapi/pull/12861\n  */\n  const valueWithEmptyStringFallback = value ?? '';\n\n  function getErrorMessage(error: string | TranslationMessage | undefined) {\n    if (!error) {\n      return null;\n    }\n\n    if (typeof error === 'string') {\n      return formatMessage({ id: error, defaultMessage: error });\n    }\n\n    const values = {\n      ...error.values,\n    };\n\n    return formatMessage(\n      {\n        id: error.id,\n        defaultMessage: error?.defaultMessage ?? error.id,\n      },\n      values\n    );\n  }\n\n  const errorMessage = getErrorMessage(error) ?? undefined;\n\n  if (CustomInput) {\n    return (\n      <CustomInput\n        {...rest}\n        attribute={attribute}\n        description={description}\n        hint={hint}\n        disabled={disabled}\n        intlLabel={intlLabel}\n        labelAction={labelAction}\n        error={errorMessage || ''}\n        name={name}\n        onChange={onChange}\n        options={options}\n        required={required}\n        placeholder={placeholder}\n        type={type}\n        value={value}\n      />\n    );\n  }\n\n  const label = intlLabel.id\n    ? formatMessage(\n        { id: intlLabel.id, defaultMessage: intlLabel.defaultMessage },\n        { ...intlLabel.values }\n      )\n    : name;\n\n  const formattedPlaceholder = placeholder\n    ? formatMessage(\n        { id: placeholder.id, defaultMessage: placeholder.defaultMessage },\n        { ...placeholder.values }\n      )\n    : '';\n\n  const getComponent = () => {\n    switch (type) {\n      case 'json': {\n        return (\n          <JSONInput\n            value={value}\n            disabled={disabled}\n            onChange={(json) => {\n              // Default to null when the field is not required and there is no input value\n              const value =\n                attribute && 'required' in attribute && !attribute?.required && !json.length\n                  ? null\n                  : json;\n              onChange({ target: { name, value } }, false);\n            }}\n            minHeight=\"25.2rem\"\n            maxHeight=\"50.4rem\"\n          />\n        );\n      }\n      case 'bool': {\n        return (\n          <Toggle\n            checked={defaultValue === null ? null : defaultValue || false}\n            disabled={disabled}\n            offLabel={formatMessage({\n              id: 'app.components.ToggleCheckbox.off-label',\n              defaultMessage: 'False',\n            })}\n            onLabel={formatMessage({\n              id: 'app.components.ToggleCheckbox.on-label',\n              defaultMessage: 'True',\n            })}\n            onChange={(e) => {\n              onChange({ target: { name, value: e.target.checked } });\n            }}\n          />\n        );\n      }\n      case 'checkbox': {\n        return (\n          <Checkbox\n            disabled={disabled}\n            onCheckedChange={(value) => {\n              onChange({ target: { name, value } });\n            }}\n            checked={Boolean(value)}\n          >\n            {label}\n          </Checkbox>\n        );\n      }\n      case 'datetime': {\n        const dateValue = parseDateValue(value);\n        return (\n          <DateTimePicker\n            clearLabel={formatMessage({ id: 'clearLabel', defaultMessage: 'Clear' })}\n            disabled={disabled}\n            onChange={(date) => {\n              // check if date is not null or undefined\n              const formattedDate = date ? date.toISOString() : null;\n\n              onChange({ target: { name, value: formattedDate, type } });\n            }}\n            onClear={() => onChange({ target: { name, value: null, type } })}\n            placeholder={formattedPlaceholder}\n            value={dateValue}\n          />\n        );\n      }\n      case 'date': {\n        const dateValue = parseDateValue(value);\n        return (\n          <DatePicker\n            clearLabel={formatMessage({ id: 'clearLabel', defaultMessage: 'Clear' })}\n            disabled={disabled}\n            onChange={(date) => {\n              onChange({\n                target: {\n                  name,\n                  value: date ? formatISO(date, { representation: 'date' }) : null,\n                  type,\n                },\n              });\n            }}\n            onClear={() => onChange({ target: { name, value: null, type } })}\n            placeholder={formattedPlaceholder}\n            value={dateValue}\n          />\n        );\n      }\n      case 'number': {\n        return (\n          <NumberInput\n            disabled={disabled}\n            onValueChange={(value) => {\n              onChange({ target: { name, value, type } });\n            }}\n            placeholder={formattedPlaceholder}\n            step={step}\n            value={value}\n          />\n        );\n      }\n      case 'email': {\n        return (\n          <TextInput\n            autoComplete={autoComplete}\n            disabled={disabled}\n            onChange={(e) => {\n              onChange({ target: { name, value: e.target.value, type } });\n            }}\n            placeholder={formattedPlaceholder}\n            type=\"email\"\n            value={valueWithEmptyStringFallback}\n          />\n        );\n      }\n      case 'timestamp':\n      case 'text':\n      case 'string': {\n        return (\n          <TextInput\n            autoComplete={autoComplete}\n            disabled={disabled}\n            onChange={(e) => {\n              onChange({ target: { name, value: e.target.value, type } });\n            }}\n            placeholder={formattedPlaceholder}\n            type=\"text\"\n            value={valueWithEmptyStringFallback}\n          />\n        );\n      }\n      case 'password': {\n        return (\n          <TextInput\n            autoComplete={autoComplete}\n            disabled={disabled}\n            endAction={\n              <button\n                aria-label={formatMessage({\n                  id: 'Auth.form.password.show-password',\n                  defaultMessage: 'Show password',\n                })}\n                onClick={() => {\n                  setShowPassword((prev) => !prev);\n                }}\n                style={{\n                  border: 'none',\n                  padding: 0,\n                  background: 'transparent',\n                }}\n                type=\"button\"\n              >\n                {showPassword ? <Eye fill=\"neutral500\" /> : <EyeStriked fill=\"neutral500\" />}\n              </button>\n            }\n            onChange={(e) => {\n              onChange({ target: { name, value: e.target.value, type } });\n            }}\n            placeholder={formattedPlaceholder}\n            type={showPassword ? 'text' : 'password'}\n            value={valueWithEmptyStringFallback}\n          />\n        );\n      }\n      case 'select': {\n        return (\n          <SingleSelect\n            disabled={disabled}\n            onChange={(value) => {\n              onChange({ target: { name, value, type: 'select' } });\n            }}\n            placeholder={formattedPlaceholder}\n            value={value}\n          >\n            {options.map(({ metadatas: { intlLabel, disabled, hidden }, key, value }) => {\n              return (\n                <SingleSelectOption key={key} value={value} disabled={disabled} hidden={hidden}>\n                  {formatMessage(intlLabel)}\n                </SingleSelectOption>\n              );\n            })}\n          </SingleSelect>\n        );\n      }\n      case 'textarea': {\n        return (\n          <Textarea\n            disabled={disabled}\n            onChange={(event) => onChange({ target: { name, value: event.target.value, type } })}\n            placeholder={formattedPlaceholder}\n            value={valueWithEmptyStringFallback}\n          />\n        );\n      }\n      case 'time': {\n        const formattedValue = handleTimeChange({ value, onChange, name, type });\n\n        return (\n          <TimePicker\n            clearLabel={formatMessage({ id: 'clearLabel', defaultMessage: 'Clear' })}\n            disabled={disabled}\n            onChange={(time) => handleTimeChangeEvent(onChange, name, type, time)}\n            onClear={() => handleTimeChangeEvent(onChange, name, type, undefined)}\n            value={formattedValue}\n          />\n        );\n      }\n      default: {\n        /**\n         * If there's no component for the given type, we return a disabled text input\n         * showing a \"Not supported\" title to illustrate the issue.\n         */\n        return <TextInput disabled placeholder=\"Not supported\" type=\"text\" value=\"\" />;\n      }\n    }\n  };\n\n  return (\n    <Field.Root error={errorMessage} name={name} hint={hint} required={required}>\n      {type !== 'checkbox' ? <Field.Label action={labelAction}>{label}</Field.Label> : null}\n      {getComponent()}\n      <Field.Error />\n      <Field.Hint />\n    </Field.Root>\n  );\n};\n\ntype FieldSchema = {\n  minLength?: number | string;\n  maxLength?: number | string;\n  max?: number | string;\n  min?: number | string;\n};\ninterface UseFieldHintProps {\n  description?: MessageDescriptor & { values?: Record<string, PrimitiveType> };\n  fieldSchema?: FieldSchema;\n  type?: string;\n}\n\n/**\n * @description\n * A hook for generating the hint for a field\n */\nconst useFieldHint = ({ description, fieldSchema, type }: UseFieldHintProps) => {\n  const { formatMessage } = useIntl();\n\n  const buildDescription = () =>\n    description?.id\n      ? formatMessage(\n          { id: description.id, defaultMessage: description.defaultMessage },\n          { ...description.values }\n        )\n      : '';\n\n  const buildHint = () => {\n    const { maximum, minimum } = getMinMax(fieldSchema);\n    const units = getFieldUnits({\n      type,\n      minimum,\n      maximum,\n    });\n\n    const minIsNumber = typeof minimum === 'number';\n    const maxIsNumber = typeof maximum === 'number';\n    const hasMinAndMax = maxIsNumber && minIsNumber;\n    const hasMinOrMax = maxIsNumber || minIsNumber;\n\n    if (!description?.id && !hasMinOrMax) {\n      return '';\n    }\n\n    return formatMessage(\n      {\n        id: 'content-manager.form.Input.hint.text',\n        defaultMessage:\n          '{min, select, undefined {} other {min. {min}}}{divider}{max, select, undefined {} other {max. {max}}}{unit}{br}{description}',\n      },\n      {\n        min: minimum,\n        max: maximum,\n        description: buildDescription(),\n        unit: units?.message && hasMinOrMax ? formatMessage(units.message, units.values) : null,\n        divider: hasMinAndMax\n          ? formatMessage({\n              id: 'content-manager.form.Input.hint.minMaxDivider',\n              defaultMessage: ' / ',\n            })\n          : null,\n        br: hasMinOrMax ? <br /> : null,\n      }\n    );\n  };\n\n  return { hint: buildHint() };\n};\n\nconst getFieldUnits = ({\n  type,\n  minimum,\n  maximum,\n}: {\n  type?: string;\n  minimum?: number;\n  maximum?: number;\n}) => {\n  if (type && ['biginteger', 'integer', 'number'].includes(type)) {\n    return {};\n  }\n  const maxValue = Math.max(minimum || 0, maximum || 0);\n\n  return {\n    message: {\n      id: 'content-manager.form.Input.hint.character.unit',\n      defaultMessage: '{maxValue, plural, one { character} other { characters}}',\n    },\n    values: {\n      maxValue,\n    },\n  };\n};\n\nconst getMinMax = (fieldSchema?: FieldSchema) => {\n  if (!fieldSchema) {\n    return { maximum: undefined, minimum: undefined };\n  }\n\n  const { minLength, maxLength, max, min } = fieldSchema;\n\n  let minimum;\n  let maximum;\n\n  const parsedMin = Number(min);\n  const parsedMinLength = Number(minLength);\n\n  if (!Number.isNaN(parsedMin)) {\n    minimum = parsedMin;\n  } else if (!Number.isNaN(parsedMinLength)) {\n    minimum = parsedMinLength;\n  }\n\n  const parsedMax = Number(max);\n  const parsedMaxLength = Number(maxLength);\n\n  if (!Number.isNaN(parsedMax)) {\n    maximum = parsedMax;\n  } else if (!Number.isNaN(parsedMaxLength)) {\n    maximum = parsedMaxLength;\n  }\n\n  return { maximum, minimum };\n};\n\n/**\n * we've memoized this component because we use a context to store all the data in our form in the content-manager.\n * This then causes _every_ component to re-render because there are no selects incurring performance issues\n * in content-types as the content-type gets more complicated.\n */\nconst MemoizedGenericInput = React.memo(GenericInput, isEqual);\n\nexport type { GenericInputProps, CustomInputProps };\nexport { MemoizedGenericInput as GenericInput };\n","import { Menu } from '@strapi/design-system';\nimport { useDispatch } from 'react-redux';\nimport { styled } from 'styled-components';\n\nimport { useDataManager } from '../../../../hooks/useDataManager';\nimport { isAllowedContentTypesForRelations } from '../../../../utils';\nimport { ON_CHANGE_RELATION_TARGET } from '../../../FormModal/constants';\n\ninterface RelationTargetPickerProps {\n  oneThatIsCreatingARelationWithAnother: string;\n  target: string;\n}\n\nexport const RelationTargetPicker = ({\n  oneThatIsCreatingARelationWithAnother,\n  target,\n}: RelationTargetPickerProps) => {\n  const { contentTypes, sortedContentTypesList } = useDataManager();\n  const dispatch = useDispatch();\n  // TODO: replace with an obj { relation: 'x', bidirctional: true|false }\n  const allowedContentTypesForRelation = sortedContentTypesList.filter(\n    isAllowedContentTypesForRelations\n  );\n\n  const { plugin = null, schema: { displayName } = { displayName: 'error' } } =\n    contentTypes?.[target] ?? {};\n\n  const handleSelect =\n    ({\n      uid,\n      plugin,\n      title,\n      restrictRelationsTo,\n    }: {\n      uid: string;\n      plugin: boolean;\n      title: string;\n      restrictRelationsTo: any;\n    }) =>\n    () => {\n      const selectedContentTypeFriendlyName = plugin ? `${plugin}_${title}` : title;\n\n      dispatch({\n        type: ON_CHANGE_RELATION_TARGET,\n        target: {\n          value: uid,\n          oneThatIsCreatingARelationWithAnother,\n          selectedContentTypeFriendlyName,\n          targetContentTypeAllowedRelations: restrictRelationsTo,\n        },\n      });\n    };\n\n  /**\n   * TODO: This should be a Select but the design doesn't match the\n   * styles of the select component and there isn't the ability to\n   * change it correctly.\n   */\n  return (\n    <Menu.Root>\n      <MenuTrigger>{`${displayName} ${plugin ? `(from: ${plugin})` : ''}`